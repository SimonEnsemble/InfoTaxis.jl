### A Pluto.jl notebook ###
# v0.20.8

using Markdown
using InteractiveUtils

# This Pluto notebook uses @bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of @bind gives bound variables a default value (instead of an error).
macro bind(def, element)
    #! format: off
    return quote
        local iv = try Base.loaded_modules[Base.PkgId(Base.UUID("6e696c72-6542-2067-7265-42206c756150"), "AbstractPlutoDingetjes")].Bonds.initial_value catch; b -> missing; end
        local el = $(esc(element))
        global $(esc(def)) = Core.applicable(Base.get, el) ? Base.get(el) : iv(el)
        el
    end
    #! format: on
end

# ╔═╡ 285d575a-ad5d-401b-a8b1-c5325e1d27e9
begin
	import Pkg; Pkg.activate()
	
	using CairoMakie, LinearAlgebra, Turing, SpecialFunctions, ColorSchemes, DataFrames, StatsBase, PlutoUI, Test, Distributions, Printf, PlutoTeachingTools, JLD2, CSV, DelimitedFiles, LatinHypercubeSampling
end

# ╔═╡ 54b50777-cfd7-43a3-bcc2-be47f117e635
TableOfContents()

# ╔═╡ 52d76437-0d60-4589-996f-461eecf0d45d
md"""
# Declarations
"""

# ╔═╡ e5b1369e-0b4b-4da3-9c95-07ceda11b31d
md"## constants"

# ╔═╡ 064eb92e-5ff0-436a-8a2b-4a233ca4fa42
begin
	# size of search space
	L = 1000.0 # m, assuming space is square
	Δx = 10.0 # m
	
	# constant attenuation for air
	Σ_air = 0.015
	
	# Detector Parameters
	ϵ = 0.95 #efficiency
	Δt = 1.0 #s
	A = 0.0224 #m^2

	# source parameters
	x₀ = [250.0, 250.0]
	P_γ = 0.85 #about 85% decays emit detectable gamma
	Σ = 0.2 #macroscopic cross section (mean free path)
	mCi = 0.050 #50 μCi
	I = mCi * 3.7 * 10^7 * P_γ # 1mCi = 3.7*10^7 Bq
	#counts/gamma - multiply this by the value normalized to #of photons

	# colors
	colormap = reverse(vcat([ColorSchemes.hot[i] for i in 0.0:0.02:1], ColorSchemes.batlow[0.0]))

	# Locate files for which data needs to be extracted
	dir_name = "sim_data"
	data_dir = joinpath(pwd(), dir_name)
	data_files = [joinpath(data_dir, file) for file in readdir(data_dir)]

	# Turing parameters
	I_max = 1e10 #emmissions/s

	# robot parameters
	r_velocity = 5.0 #m/s

end

# ╔═╡ b8d6c195-d639-4438-8cab-4dcd99ea2547
function attenuation_constant(x::Vector{Float64}, x₀; Σ::Float64=Σ_air)
    distance = norm(x .- x₀)
    return exp(-Σ * distance)
end

# ╔═╡ 82577bab-5ce9-4164-84db-9cfa28b501b0
md"""
## Structs
"""

# ╔═╡ a9c65b66-eb92-4943-91a9-9d0ea6cfa3d3
md"### obstructions"

# ╔═╡ 57478c44-578e-4b53-b656-c9b3c208dec4
begin
	abstract type Obstruction end
	
	struct Rectangle <: Obstruction
	    center::Tuple{Float64, Float64}
	    width::Float64
	    height::Float64
	end
	
	struct Circle <: Obstruction
	    center::Tuple{Float64, Float64}
	    radius::Float64
	end
	#= I set this up just in case, but I don't expect to use this...
	if we do use this, I'll probably have to use another library with inpolygon() function that determins if a point lies inside a polygon.
	struct Polygon <: Obstruction
	    vertices::Vector{Tuple{Float64, Float64}}
	end
	=#
end

# ╔═╡ 03910612-d3fe-481c-bb70-dd5578bd8258
md"### rad sim"

# ╔═╡ dd357479-64ef-4823-8aba-931323e89aed
struct RadSim
    γ_matrix::Vector{Matrix{Float64}} #vector of matrices of gamma values. Multiply by Intensity to get counts/s, each entry of the vector represents a z-slice
    Δxy::Float64 #m, the size of each step in the x,y plane of the γ_matrix
    Δz::Float64 #m, the size of each step in the z plane
    Lxy::Float64 #m, the size of the x, y plane... assume square
    Lz::Float64 #m, the size of the z plane
	x₀::Vector{Float64} #the coordinates of the source
end

# ╔═╡ 7fcecc0e-f97c-47f7-98db-0da6d6c1811e
md"""
# Data Import
"""

# ╔═╡ 9ac1e08a-cd89-4afb-92d9-2bd973f06aaa
md"## save CSV from python"

# ╔═╡ e80af66e-54ab-4661-bd49-89328c17e3d4
"""
Function to read csv file generated by the rad teams python script. This will take the python CSV file, remove extraneous characters, turn it into a matrix of 1's and 0's and orient it properly. The 1's in the matrix represent known obstructions or walls and the 0's represent empty space. Each index of the matrix represents a centimeter as interpreted by the vacuum robot.
"""
function parse_numpy_csv_file(path::String)
    raw = read(path, String)

    stripped = replace(raw, ['[', ']', '"', '\n', '.'] => "")
    tokens = split(strip(stripped))
    values = round.(Int, parse.(Float64, tokens))

    #check if it's a perfect square
    n = length(values)
    ncols = Int(round(sqrt(n)))
    @assert ncols^2 == n "Matrix is not square: total elements = $n, but sqrt = $ncols"

    #reshape into square matrix
	square_matrix = reshape(values, ncols, ncols)

	#flip y axis
	square_matrix_flipped = square_matrix[:, end:-1:1]
	
    return square_matrix_flipped
end

# ╔═╡ 2c959785-6d71-49c6-921a-16e74cb3b43e
environment = parse_numpy_csv_file(joinpath("csv", "Walls.csv"))

# ╔═╡ 0fc694a6-f4cf-478d-bd68-9af5f7f4f5b8
heatmap(environment)

# ╔═╡ 181c27f4-6830-4c4d-9392-3237564e6cb1
md"## obstruction data"

# ╔═╡ 7c44611e-2442-4dca-9624-e18676e0f67c
md"""
#### This obstruction data was provided in an email by the rad team.
"""

# ╔═╡ 52814746-ae35-4ffa-9be0-66854a4d96bf
begin
	#rectangular block x(150-350) y(650-750) z(0-200)
	wide_rect = Rectangle(
		(150.0 + (350.0-150.0)/2, 650.0 + (750.0-650.0)/2),
		350.0-150.0,
		750.0-650.0
	)
	#rectangular block x(450-550) y(450-550) z(0-200)
	square = Rectangle(
		(450.0 + (550.0-450.0)/2, 450.0 + (550.0-450.0)/2),
		550.0-450.0,
		550.0-450.0
	)
	#cylinder bottom (750,350,0) height = 200, radius = 50
	cylinder = Circle(
		(750.0, 350.0),
		50.0
	)
	obstructions = [wide_rect, square, cylinder]
end

# ╔═╡ 19c95a83-670c-4ad6-82a1-5a4b6809f1d4
"""
Helper function used by `import_data()` to convert the dictionary read from the text file into dictionary containing the components necessary to make a RadSim struct.
"""
function get_matrix_params(data::Dict)

	parameters = Dict()

	#Δx,y and L parameters
	Δxy = data["y_bin_bounds"][2] - data["y_bin_bounds"][1]
	parameters["Δxy"] = Δxy
	Δz = data["z_bin_bounds"][2] - data["z_bin_bounds"][1]
	parameters["Δz"] = Δz 
	parameters["Lxy"] = (length(data["x_bin_bounds"])-1) * Δxy
	parameters["Lz"] = (length(data["z_bin_bounds"])-1) * Δz

	#assert square grid
	@assert Δxy == data["x_bin_bounds"][2] - data["x_bin_bounds"][1] "x and y should have the same grid spacing!"
	

	norm_gamma_matrix = zeros(length(data["x_bin_bounds"])-1,
							 length(data["y_bin_bounds"])-1,
							 length(data["z_bin_bounds"])-1
							 )


	for row in eachrow(data["energy_field_data"])
		x_start = data["x_bin_bounds"][1]
		y_start = data["y_bin_bounds"][1]
		z_start = data["z_bin_bounds"][1]
	    # Compute indices from coordinates
	    i = Int(round((row["X"] - x_start) / Δxy + 0.5))
	    j = Int(round((row["Y"] - y_start)  / Δxy + 0.5))
	    k = Int(round((row["Z"] - z_start)  / Δz + 0.5))
	
		norm_gamma_matrix[i, j, k] = row["Result"]
	end

	parameters["γ_matrix"] = norm_gamma_matrix

	return parameters
end

# ╔═╡ e62ba8da-663a-4b58-afe6-910710d7518e
"""
Reads the lines of the simulation data file provided by the radiation team at path: `data_file_path::String` and returns a RadSim data struct.
"""
function import_data(data_file_path::String; x₀::Vector{Float64}=[250.0, 250.0])
	#ensure the input is a file.
	@assert isfile(data_file_path) "$(data_file_path) is not a file!!!"

	#flags used to indicate sections of the data file.
	flags = Dict(
		"tally_bin_bounds" => false,
		"x_dir" => false,
		"y_dir" => false,
		"z_dir" => false,
		"energy_grid" => false
	)

	#set up a dictionary to hold the data
	data = Dict(
		"x_bin_bounds" => Array{Float64}(undef, 0),
		"y_bin_bounds" => Array{Float64}(undef, 0),
		"z_bin_bounds" => Array{Float64}(undef, 0),
		"energy_field_data" => DataFrame(
			Energy = Array{Float64}(undef, 0),
			X = Array{Float64}(undef, 0),
			Y = Array{Float64}(undef, 0),
			Z = Array{Float64}(undef, 0),
			Result = Array{Float64}(undef, 0),
			RelError = Array{Float64}(undef, 0)
		)
	)

	#read the rad sim file line by line
	open(data_file_path) do f
		while !eof(f)
			#read the line
			f_line = lowercase(readline(f))
			# replace double+ spaces with single spaces
			s = replace(f_line, r"\s{2,}" => " ")

			#check for first line of data
			#there are two main sections, "tally bin boundaries" and "energy x y"
			if contains(s, "tally bin boundaries")
				flags["tally_bin_bounds"] = true
				continue
			elseif contains(s, "energy x y")
				flags["energy_grid"] = true
				continue
			end

			#tally bin bounds section
			#within this section we use the x, y, z direction flags
			if flags["tally_bin_bounds"]
				#if we reach the next section, turn off the flag and continue
				if contains(s, "energy bin boundaries")
					flags["tally_bin_bounds"] = false
					continue
				end
   				for dir in ["x", "y", "z"]
					#check if the beginning of a new direction
        			if occursin("$dir direction", s)
            			flags["x_dir"] = flags["y_dir"] = flags["z_dir"] = false
           				flags["$(dir)_dir"] = true
						
						values = parse.(Float64, split(s)[3:end])
						data["$(dir)_bin_bounds"] = values
					#if not the beginning of a new direction, collect data
					elseif !(occursin("direction", s))
						#only collect data for the current flagged direction
						if flags["$(dir)_dir"]
							values = parse.(Float64, split(s))
							data["$(dir)_bin_bounds"] = vcat(data["$(dir)_bin_bounds"], values)
						end
					end
				end
			end
			#for engery_grid, just push new lines to the dataframe
			if flags["energy_grid"]
				values = parse.(Float64, split(s))
				push!(data["energy_field_data"], values)
			end
		end
	end

	#convert data into a matrix
	matrix_params = get_matrix_params(data)

	#generate and return a rad_sim struct
	rad_sim = RadSim(
		[matrix_params["γ_matrix"][:, :, i] for i in 1:size(matrix_params["γ_matrix"], 3)],
		matrix_params["Δxy"],
		matrix_params["Δz"],
		matrix_params["Lxy"],
		matrix_params["Lz"],
		x₀
	)
	return rad_sim
end

# ╔═╡ 8ffaf344-1c74-48c8-a116-8c937322cd6e
md"""
## import radiation simulation data
"""

# ╔═╡ 1197e64f-34c2-4892-8da5-3b26ee6e7c2f
begin
	num_sims = length(data_files)
	rad_sim_data = [import_data(data_files[i]) for i=1:num_sims]

	test_rad_sim = rad_sim_data[1]
	test_rad_sim_obstructed = rad_sim_data[2]
end

# ╔═╡ 7278adb5-2da1-4ea1-aa38-d82c23510242
md"""
## `Visualize` - Imported Data
"""

# ╔═╡ 173feaf5-cbfa-4e94-8de5-1a5311cdf14e
"""
Obstruction visualization helper function
"""
function viz_obstructions!(ax, obstructions::Vector{Obstruction})
	for obs in obstructions
		if obs isa Rectangle
			cx, cy = obs.center
			w2, h2 = obs.width / 2, obs.height / 2
			rect_vertices = [
				(cx - w2, cy - h2),
				(cx + w2, cy - h2),
				(cx + w2, cy + h2),
				(cx - w2, cy + h2),
			]
			poly!(ax, rect_vertices, color=ColorSchemes.bamako10[1], strokewidth=1.0, transparency=true)
		elseif obs isa Circle
			θ = range(0, 2π; length=100)
			cx, cy = obs.center
			r = obs.radius
			xs = cx .+ r .* cos.(θ)
			ys = cy .+ r .* sin.(θ)
			poly!(ax, xs, ys, color=ColorSchemes.bamako10[1])
		end
	end
end

# ╔═╡ 7211ea6e-6535-4e22-a2ef-a1994e81d22a
"""
Radiation simulation RadSim, visual helper function.
"""
function viz_model_data!(
	ax, 
	rad_sim::RadSim; 
	z_slice::Int64=1, 	
	obstructions::Union{Nothing, Vector{Obstruction}}=nothing
)
	#set up a log scale
	scale = ReversibleScale(
	    x -> log10(x + 1),   # forward: avoids log(0)
	    x -> 10^x - 1        # inverse
	)

	# x and y values 
	xs = ys = [val for val in 0:rad_sim.Δxy:rad_sim.Lxy]
	#counts
	counts_I = I * rad_sim.γ_matrix[z_slice]

	hm = heatmap!(ax, xs, ys, counts_I, colormap=colormap, colorscale=scale)

	if !isnothing(obstructions)
		viz_obstructions!(ax, obstructions)
	end
	
	return hm
end

# ╔═╡ 63c8b6dd-d12a-42ec-ab98-1a7c6a991dbd
"""
Visualize simulated radiation data provided by the radiation team.

* `rad_sim::RadSim` - the radiation simulation data structure after being imported.
* `z_slice::Int64=1` - change to change the z slice of the data, unless the data has more than 2-dimensional data, just keep as 1.
* `obstructions::Union{Nothing, Vector{Obstruction}}=nothing` - optional obstruction data, if provided obstructions will be visualized as teal blocks.
"""
function viz_model_data(
	rad_sim::RadSim; 
	z_slice::Int64=1, 
	obstructions::Union{Nothing, Vector{Obstruction}}=nothing
)
	fig = Figure()
	ax  = Axis(
	    fig[1, 1], 
	    aspect=DataAspect(), 
	    xlabel="x₁", 
	    ylabel="x₂"
	)

	#convert normalized gammas to counts
	counts_I = I * rad_sim.γ_matrix[z_slice]
	
	hm = viz_model_data!(ax, rad_sim, obstructions=obstructions)

	#establish logarithmic colorbar tick values
	colorbar_tick_values = [10.0^e for e in range(0, log10(maximum(counts_I)), length=6)]
	colorbar_tick_values[1] = 0.0
	colorbar_tick_labels = [@sprintf("%.0e", val) for val in colorbar_tick_values]

	Colorbar(fig[1, 2], hm, label = "counts / s", ticks = (colorbar_tick_values, colorbar_tick_labels))
	
	fig
end

# ╔═╡ 1f12fcd1-f962-45e9-8c07-4f42f869d6a0
viz_model_data(test_rad_sim)

# ╔═╡ bbeed200-3315-4546-9540-16864843f178
viz_model_data(test_rad_sim_obstructed, obstructions=obstructions)

# ╔═╡ 3ee48a88-3b6a-4995-814b-507679065ff4
md"# Create Grid for Vaacuum"

# ╔═╡ 6fdb31a6-f287-40a4-8c21-2ef92ff90a99
"""
Identifies points that are too close (i.e. within radius) of a wall. This is being used to thicken walls for the flood fill algorithm.
"""
function clearance_mask(env::Matrix{Int}, radius::Int)
    h, w = size(env)
    mask = falses(h, w)

    for y in 1:h, x in 1:w
        for dy in -radius:radius, dx in -radius:radius
            yy, xx = y + dy, x + dx
			#check if the current grid location is too close to an obstacle
            if xx ≥ 1 && xx ≤ w && yy ≥ 1 && yy ≤ h && env[yy, xx] == 1
                mask[y, x] = true
                break
            end
        end
    end

    return mask
end


# ╔═╡ ca763f28-d2b2-4eac-ae6c-90f74e3c42e7
"""
Breadth first search flood fill (paint bucket) algorithm. Finds adjacent locations that are accessible from a seed location and returns a new matrix excluding locations that cannot be accessed from the seed by traveling adjacently.

* `env::Matrix{Int}` - Matrix containing only 0's and 1's, where a 0 represents open space and a 1 represents an obstruction.
* `seed::Tuple{Int, Int}` - The starting location (indicies) for the paint bucket, this index must point to a 0 such that `env[seed]==0`.
* `clearance_radius::Int=5` - The thickness of walls, larger values will ensure small openings are blocked, set to 0 to not use a mask at all.
"""
function flood_fill(
	env::Matrix{Int}, 
	seed::Tuple{Int, Int}; 
	clearance_radius::Int=5
)
    h, w = size(env)
    buffer_zone = clearance_mask(env, clearance_radius)
    visited = falses(h, w)

	#check seed validity
    x₀, y₀ = seed
    if env[y₀, x₀] != 0 || buffer_zone[y₀, x₀]
        error("Seed is not in valid, clear space")
    end

	#initialize q as the seed location
    q = [(x₀, y₀)]

	#flood fill algorithm, builds out from the seed until it runs into the buffer_zone
    while !isempty(q)
        (x, y) = pop!(q)

        if x < 1 || x > w || y < 1 || y > h
            continue
        elseif visited[y, x] || env[y, x] != 0 || buffer_zone[y, x]
            continue
        end

        visited[y, x] = true
        append!(q, [(x+1, y), (x-1, y), (x, y+1), (x, y-1)])
    end

	#remake environment as 0's and 1's
    new_env = copy(env)
    for y in 1:h, x in 1:w
        if env[y, x] == 0 && !visited[y, x]
            new_env[y, x] = 1
        end
    end

    return new_env
end


# ╔═╡ 00f909f7-86fd-4d8e-8db2-6a587ba5f12d
begin
	environment_masked = flood_fill(environment, (250, 250), clearance_radius=5)
	heatmap(environment_masked)
end

# ╔═╡ 5e7dc22c-dc2d-41b0-bb3e-5583a5b79bdd
"""
Generates a matrix of locations for a robot to explore of user defined coarseness.

* `environment::Matrix{Int}` - Matrix containing only 0's and 1's, where a 0 represents open space and a 1 represents an obstruction.
* `step::Int` - The size of each step in the robot exploration matrix. For example, a step of 10 means each index in the robot matrix is 10 times further apart then the original obstruction map.
* `mask_outside::Bool=true` - set to true to use flood fill algorithm (paint bucket) to try and remove inaccessible sections of the map.
* `seed::Tuple{Int, Int}=(250,250)` - The starting location (indicies) for the paint bucket, this index must point to a 0 such that `env[seed]==0`.
* `clearance_radius::Int=5` - adjusts the clearance radius of the mask, i.e. thickens the walls.
"""
function generate_robot_grid_matrix(
	environment::Matrix{Int}, 
	step::Int; 
	mask_outside::Bool=true, 
	seed::Tuple{Int, Int}=(250,250), 
	clearance_radius::Int=5
)
    h, w = size(environment)

    # Optionally apply flood fill to exclude disconnected regions
    if mask_outside
        environment = Int.(flood_fill(environment, 
									  seed, 
									  clearance_radius=clearance_radius
									 )
						  )
    end
    grid_rows = cld(h, step)
    grid_cols = cld(w, step)

    #grid is made of x, y coordinates of original robot space and boolean to represent accessibility
    grid = Array{Union{Int, Bool}}(undef, grid_rows, grid_cols, 3)

    for i in 1:grid_rows
        for j in 1:grid_cols
            y = min((i - 1) * step + 1, h)
            x = min((j - 1) * step + 1, w)
            valid = environment[y, x] == 0
            grid[i, j, 1] = x
            grid[i, j, 2] = y
            grid[i, j, 3] = valid
        end
    end

    return grid
end

# ╔═╡ 4bda387f-4130-419c-b9a5-73ffdcc184f9
grid = generate_robot_grid_matrix(environment, 10)

# ╔═╡ 560de084-b20b-45d7-816a-c0815f398e6d
md"""
## `Visualize` - Rad source search grid
"""

# ╔═╡ 45014b50-c04b-4f42-83c3-775ec6cd6e3f
"""
Visualize the robot search grid over the environment.

* `environment::Matrix{Int}` - Matrix containing only 0's and 1's, where a 0 represents open space and a 1 represents an obstruction.
* `robot_grid::Array{<:Any,3}` - The array generated from the `generate_robot_grid_matrix()` function where the first two values are the x and y coordinates of each grid location for the robot search space and the third value is the matrix of boolean values representing accessibility of locations.
"""
function viz_robot_grid(
	environment::Matrix{Int}, 
	robot_grid::Array{<:Any,3}; 
	fig_size::Int=800
)
    fig = Figure(size=(fig_size, fig_size))
    ax = Axis(fig[1, 1], aspect=DataAspect(), title="rad source search grid")

    heatmap!(ax, environment; colormap = :grays)

    n_valid = count(robot_grid[:, :, 3] .== true)

    xs = zeros(Float64, n_valid)
    ys = zeros(Float64, n_valid)

    idx = 1
	#loop through the grid and add true values to the scatter plot
    for i in 1:size(robot_grid, 1), j in 1:size(robot_grid, 2)
        if robot_grid[j, i, 3] == true
            xs[idx] = robot_grid[i, j, 1]
            ys[idx] = robot_grid[i, j, 2]
            idx += 1
        end
    end

    scatter!(ax, xs, ys; color = :cyan, markersize = 10)

    return fig
end


# ╔═╡ d47b2021-7129-4a31-8585-2c7257489b1a
viz_robot_grid(environment, grid)

# ╔═╡ 849ef8ce-4562-4353-8ee5-75d28b1ac929
md"# Analytical (Poisson) Model"

# ╔═╡ e622cacd-c63f-416a-a4ab-71ba9d593cc8
"""
Generates a Poisson distribution based on position, source position and source strength.

* `x::Vector{Float64}` - Measurement/true value location.
* `x₀::Vector{Float64}` - source location.
* `I::Float64` - source strength in Bq.
"""
function count_Poisson(x::Vector{Float64}, x₀, I)
	distance = norm(x₀ .- x)
	attenuation = attenuation_constant(x, x₀)
	λ = I * Δt * ϵ * (A / (4π * distance^2)) * exp(-attenuation)

	#this piece became necessary as NAN or negative values were being tested by the optimizer causing errors
	if isnan(λ) || λ < 0
		return Poisson(0.0)
	else
		return Poisson(λ)
	end
end

# ╔═╡ 8ed5d321-3992-40db-8a2e-85abc3aaeea0
md"""
## `Visualize` - Analytical Model
"""

# ╔═╡ 0175ede7-b2ab-4ffd-8da1-278120591027
function viz_c_analytical!(ax, color_scale; res::Int=500, L::Float64=1000.0, x₀::Vector{Float64}=[251.0, 251.0], I::Float64=1.16365e10, source::Union{Nothing, Vector{Float64}}=nothing, scale_max::Float64=1e6)
	#colormap = reverse([ColorSchemes.hot[i] for i in 0.0:0.05:1])

	xs = collect(0.0:Δx:L)
	counts = [mean(count_Poisson([x₁, x₂], x₀, I)) for x₁ in xs, x₂ in xs] # counts

	hm = heatmap!(ax, xs, xs, counts, colormap=colormap, colorscale = color_scale, colorrange=(0, scale_max))

	if ! isnothing(source)
		scatter!(ax, [source[1]], [source[2]], color="red", marker=:xcross, markersize=15, label="source", strokewidth=1)
	end

	return hm, counts
end

# ╔═╡ 6fa37ac5-fbc2-43c0-9d03-2d194e136951
function viz_c_analytical(; res::Int=500, L::Float64=1000.0, x₀::Vector{Float64}=[251.0, 251.0], I::Float64=1.16365e10, source::Union{Nothing, Vector{Float64}}=nothing, scale_max::Float64=1e5)
	fig = Figure()
	ax  = Axis(
	    fig[1, 1], 
	    aspect=DataAspect(), 
	    xlabel="x₁", 
	    ylabel="x₂"
	)

	scale = ReversibleScale(
	    x -> log10(x + 1),   # forward: avoids log(0)
	    x -> 10^x - 1        # inverse
	)

	hm, _ = viz_c_analytical!(ax, scale, res=res, L=L, x₀=x₀, I=I, source=source, scale_max=scale_max)

	colorbar_tick_values = [10.0^e for e in range(0, log10(scale_max), length=6)]
	colorbar_tick_values[1] = 0.0
	colorbar_tick_labels = [@sprintf("%.0e", val) for val in colorbar_tick_values]
	

	Colorbar(fig[1, 2], hm, label = "counts / s", ticks = (colorbar_tick_values, colorbar_tick_labels))
	
	fig
end

# ╔═╡ bc761684-699f-430b-bcb9-9b03410fa1d5
mean(Poisson(5.0))

# ╔═╡ 5b9aaaeb-dbb3-4392-a3a1-ccee94d75fed
viz_c_analytical(scale_max = 1.0*10^6)

# ╔═╡ 31864185-6eeb-4260-aa77-c3e94e467558
md"# Simulate Movement"

# ╔═╡ 015b9f4d-09b8-49f3-bc03-2fd3b972e933
md"## sample environment"

# ╔═╡ bfe17543-7b54-4f52-9679-f723adafdbdd
md"## movement"

# ╔═╡ 83052e75-db08-4e0a-8c77-35487c612dae
function pos_to_index(pos::Vector{Float64}; Δx::Float64=10.0)
    x₁ = Int(floor((pos[1]) / Δx)) + 1
    x₂ = Int(floor((pos[2]) / Δx)) + 1
    return (x₁, x₂)
end

# ╔═╡ 126df6ec-9074-4712-b038-9371ebdbc51d
function sample_model(x::Vector{Float64}, rad_sim::RadSim; I::Float64=I, Δx::Float64=Δx, z_index::Int=1)
	counts_I = I * rad_sim.γ_matrix[z_index]
	@assert count([round(Int, x[i] / Δx) <= size(counts_I, i) && x[i] >= 0.0 for i=1:2]) == 2 "r coordinate values outside of domain"

	#add background noise
	λ_background = 1.5
	noise = rand(Poisson(λ_background)) * rand([-1, 1])

	#get index from position
	indicies = pos_to_index(x)
	measurement = counts_I[indicies[1] , indicies[2] , z_index] + noise
	measurement = max(measurement, 0)

	return round(Int, measurement)
end

# ╔═╡ c6c39d74-4620-43df-8eb1-83c436924530
function get_Δ(direction::Symbol; Δx::Float64=Δx)
		if direction == :left
			Δ = [-Δx, 0.0]
		elseif direction == :right
			Δ = [Δx, 0.0]
		elseif direction == :up
			Δ = [0.0, Δx]
		elseif direction == :down
			Δ = [0.0, -Δx]
		else
			error("direction not valid")
		end

	return Δ
end

# ╔═╡ 3c0f8b63-6276-488c-a376-d5c554a5555d
	function move!(robot_path::Vector{Vector{Float64}}, direction::Symbol; Δx::Float64=Δx)
		Δ = get_Δ(direction, Δx=Δx)
		push!(robot_path, robot_path[end] + Δ)
	end

# ╔═╡ de738002-3e80-4aab-bedb-f08533231ed7
md"## `Visualize` - Movement and Measurement"

# ╔═╡ 82425768-02ba-4fe3-ab89-9ac95a45e55e
function viz_path!(ax, path_data::DataFrame; scale_max::Real=1e6, show_lines::Bool=true)

	positions = [(row["x [m]"][1], row["x [m]"][2]) for row in eachrow(path_data)]
	if show_lines
		if length(positions) > 1
		    color_map = reverse([ColorSchemes.hot[i] for i in range(0, 1.0, length=length(positions))])
		    line_colors = [get(reverse(ColorSchemes.winter), i) for i in range(0, stop=1.0, length=length(positions))]
		    line_widths = collect(reverse(range(0.5, stop=6.0, length=length(positions))))
		
		    for i in 1:length(positions)-1
		        r1, y1 = positions[i]
		        r2, y2 = positions[i+1]
		        lines!(ax, [r1, r2], [y1, y2], color=line_colors[i], linewidth=line_widths[i], joinstyle = :round)
		    end
		end
	end

	scale = ReversibleScale(
		    x -> log10(x + 1),   # forward: avoids log(0)
		    x -> 10^x - 1        # inverse
		)

	sc = scatter!(
			[row["x [m]"][1] for row in eachrow(path_data)],
			[row["x [m]"][2] for row in eachrow(path_data)],
			color=[row["counts"][1] for row in eachrow(path_data)],
			colormap=colormap,
			colorscale = scale,
			colorrange=(0.0, scale_max),
			strokewidth=2,
			markersize=11
		)

	return sc
end

# ╔═╡ 50832f87-c7eb-4418-9864-0f807a16e7a7
md"## Spiral movement"

# ╔═╡ 7d0e24e2-de5b-448c-8884-4d407ead1319
mutable struct SpiralController
    pos::Vector{Float64}
    directions::Vector{Symbol}
    dir_idx::Int
    step_size::Int
    step_increment::Int
    leg_count::Int 
end

# ╔═╡ 22652624-e2b7-48e9-bfa4-8a9473568f9d
"""
Initialize a spiral controller.

* `start_pos` - the current location (where the spiral begins)
* `step_init::Int=2` - the size of the initial step
* `step_incr::Int=2` - the number of steps by which the spiral will incrementally increase
"""
function init_spiral(start_pos::Vector{Float64}; step_init::Int=2, step_incr::Int=2)
    return SpiralController(
        start_pos,
        [:right, :up, :left, :down],
        1,
        step_init,
        step_incr,
        0
    )
end

# ╔═╡ 3ae4c315-a9fa-48bf-9459-4b7131f5e2eb
md"# Turing MCMC"

# ╔═╡ c6783f2e-d826-490f-93f5-3da7e2717a02
md"## naive rad model"

# ╔═╡ 1e7e4bad-16a0-40ee-b751-b2f3664f6620
@model function rad_model(data)
	# source location
    x₀ ~ filldist(Uniform(0.0, L), 2)
	# source strength
	I ~ Uniform(0.0, I_max)

    for i in 1:nrow(data)
        data[i, "counts"] ~ count_Poisson(data[i, "x [m]"], x₀, I)
    end

    return nothing
end

# ╔═╡ 21486862-b3c2-4fcc-98b2-737dcc5211fb
md"## `Visualize` - Turing chain"

# ╔═╡ 0a39daaa-2c20-471d-bee3-dcc06554cf78
function viz_chain_data!(ax, chain::DataFrame; show_source::Bool=true)

	scatter!(ax,
		chain[:, "x₀[1]"], chain[:, "x₀[2]"], marker=:+
	)
	if show_source
		scatter!(ax, x₀[1], x₀[2], color="red", label="source", marker=:xcross, markersize=15, strokewidth=1)
		axislegend(ax, location=:tr)
	end
end

# ╔═╡ deae0547-2d42-4fbc-b3a9-2757fcfecbaa
function viz_data_collection(
	path_data::DataFrame; 
	x₀::Union{Nothing, Vector{Float64}}=nothing, 
	rad_sim::Union{Nothing, RadSim}=nothing, 
	res::Float64=1000.0, 
	L::Float64=1000.0, 
	scale_max::Float64=1e6, 
	z_slice::Int64=1, 
	save_num::Int64=0, 	
	obstructions::Union{Nothing, Vector{Obstruction}}=nothing, chain_data::Union{Nothing, DataFrame}=nothing
)	    
	
	fig = Figure(size=(res, res))
	ax  = Axis(
	    fig[1, 1], 
	    aspect=DataAspect(), 
	    xlabel="x₁", 
	    ylabel="x₂",
		xlabelsize=40,
		ylabelsize=40,
		xticklabelsize=21,
		yticklabelsize=21
	)

	if ! isnothing(rad_sim)
		#get source, grid size and scale_max from data
		counts_I = I * rad_sim.γ_matrix[z_slice]
		source_coord = argmax(counts_I)
		source = [coord * rad_sim.Δxy for coord in source_coord.I]
		source[1] = source[1] - Δx
		scale_max = maximum(counts_I)
		L = rad_sim.Lxy
		
		scale = ReversibleScale(
		    x -> log10(x + 1),   # forward: avoids log(0)
		    x -> 10^x - 1        # inverse
		)
		
		
		hm = viz_model_data!(ax, rad_sim, obstructions=obstructions)

		colorbar_tick_values = [10.0^e for e in range(0, log10(scale_max), length=6)]
		colorbar_tick_values[1] = 0.0

		colorbar_tick_labels = [@sprintf("%.0e", val) for val in colorbar_tick_values]

		Colorbar(fig[1, 2], hm, label = "counts", ticks = (colorbar_tick_values, colorbar_tick_labels), ticklabelsize=25, labelsize=35)
	end

	sc = viz_path!(ax, path_data, scale_max=scale_max)

	if ! isnothing(x₀) || ! isnothing(rad_sim)
		scatter!([source[1]], [source[2]], color="black", marker=:xcross, markersize=25, label="source", strokewidth=1)

		#axislegend(location=:tr)
	end

	if ! isnothing(chain_data)
		viz_chain_data!(ax, chain_data, show_source=false)
	end
	
	xlims!(0-Δx, L+Δx)
	ylims!(0-Δx, L+Δx)
	
	if isnothing(rad_sim)
		Colorbar(fig[1, 2], sc, label="counts")
	end

	#
	if save_num > 0
		save("$(save_num).png", fig)
	end
	
	fig
end

# ╔═╡ 2fe974fb-9e0b-4c5c-9a5a-a5c0ce0af065
function viz_chain_data(chain::DataFrame; res::Float64=800.0, L::Float64=L, show_source::Bool=true, path_data::Union{Nothing, DataFrame}=nothing, scale_max::Real=200.0)
	fig = Figure(size = (res, res))
	ax = Axis(fig[1, 1], aspect=DataAspect())

	viz_chain_data!(ax, chain, show_source=show_source)

	if !isnothing(path_data)
		sc = viz_path!(ax, path_data, scale_max=scale_max)
		colorbar_tick_values = [10.0^e for e in range(0, log10(scale_max), length=6)]
		colorbar_tick_values[1] = 0.0

		colorbar_tick_labels = [@sprintf("%.0e", val) for val in colorbar_tick_values]

		Colorbar(fig[1, 2], sc, label = "counts", ticks = (colorbar_tick_values, colorbar_tick_labels), ticklabelsize=15, labelsize=25)
	end

	xlims!(-1, L+1)
	ylims!(-1, L+1)
	
	return fig
end

# ╔═╡ 65d603f4-4ef6-4dff-92c1-d6eef535e67e
md"## `Visualize` - Turing chain heatmap"

# ╔═╡ 6da11e28-c276-4f45-a1aa-2c86ab26c85a
function chain_to_P(chain::DataFrame; Δx::Float64=Δx, L::Float64=L)
	x_edges = collect(0.0:Δx:L+2) .- Δx/2
	hist_x₀ = fit(
		Histogram, (chain[:, "x₀[1]"], chain[:, "x₀[2]"]), (x_edges, x_edges)
	)
	return hist_x₀.weights / sum(hist_x₀.weights)
end

# ╔═╡ 50830491-6285-4915-b59a-fa5bb7298e51
function x_to_bin(x::Float64; Δx::Float64=Δx, L::Float64=L)
	x_edges = collect(0.0:Δx:L+Δx) .- Δx/2
	
	for b = 1:length(x_edges)-1
		if x < x_edges[b+1]
			return b
		end
	end
end

# ╔═╡ 065befd1-f652-4925-b1b2-4e847a3884dd
function edges_to_centers(; Δx::Float64=Δx, L::Float64=L)
	x_edges = collect(0.0:Δx:L+Δx) .- Δx/2
	n = length(x_edges)
	return [(x_edges[i] + x_edges[i+1]) / 2 for i = 1:n-1]
end

# ╔═╡ e7567ef6-edaa-4061-9457-b04895a2fca2
x_bin_centers = edges_to_centers()

# ╔═╡ aa72cf61-839d-4707-95c8-0a9230e77d56
md"## `Visualize` - Posterior"

# ╔═╡ f4d234f9-70af-4a89-9a57-cbc524ec52b4
function viz_posterior(chain::DataFrame)
	fig = Figure()

	# dist'n of I
	ax_t = Axis(fig[1, 1], xlabel="I [g/L]", ylabel="density", xscale=log10)
	hist!(ax_t, chain[:, "I"], bins=[10.0^e for e in range(0, log10(I_max), length=50)])
	#xscale!(ax_t, :log10)

	# dist'n of x₀
	ax_b = Axis(
		fig[2, 1], xlabel="x₁ [m]", ylabel="x₂ [m]", aspect=DataAspect()
	)
	xlims!(ax_b, 0, L)
	ylims!(ax_b, 0, L)
	hb = hexbin!(
		ax_b, chain[:, "x₀[1]"], chain[:, "x₀[2]"], colormap=colormap, bins=round(Int, L/Δx)
	)
	Colorbar(fig[2, 2], hb, label="count")

	# show ground-truth
	vlines!(ax_t, I, color="red", linestyle=:dash)
	scatter!(ax_b, [x₀[1]], [x₀[2]], marker=:+, color="red")
	fig
end

# ╔═╡ 95837cad-192d-46b4-aaa4-c86e9b1d1c09
md"# Exploration control"

# ╔═╡ 8c18d4e8-fd5c-4fd4-8f1e-516615a9e5f0
md"## Entropy"

# ╔═╡ ed8381e3-7a83-4afc-a95d-5cbd03b7e852
"""
entropy of the posterior over source location.
"""
function entropy(chain::DataFrame)
	P = chain_to_P(chain)
	entropy = sum(
		[-P[i] * log2(P[i]) for i in eachindex(P) if P[i] > 0.0]
	)
	return entropy
end

# ╔═╡ eafb66bc-6da3-4570-b62a-922627e6ccde
md"## `Visualize` - Simulation chain entropy"

# ╔═╡ 600a5f36-cfa2-4848-8984-44f0ae54ed67
function viz_sim_chain_entropy(chains::Dict)

	num_sims = length(chains)
	entropys = [entropy(chains[i]) for i=1:num_sims]

	fig = Figure()
	ax = Axis(fig[1, 1], xlabel="step", ylabel="posterior entropy")

	lines!(ax, 1:num_sims, entropys)

	fig
end

# ╔═╡ 28f9219a-6758-4aa3-8f96-f5b2e8a8e5d7
function viz_sim_chain_σ(chains::Dict; window_size::Int=10, use_diff::Bool=true)
	function movmean(v::Vector{<:Real}, window::Int)
	    n = length(v)
	    result = similar(v, Float64)
	    for i in 1:n
	        start_idx = max(1, i - window + 1)
	        result[i] = mean(@view v[start_idx:i])
	    end
	    return result
	end
	
	num_sims = length(chains)
	σs = zeros(num_sims)

	#Calculate the Euclidean norm or L2 norm or root sum of squares RSS.
	for i=1:num_sims
		σₓ₁ = std(chains[i][:, "x₀[1]"])
		σₓ₂ = std(chains[i][:, "x₀[2]"])
		σ_total = sqrt(σₓ₁^2 + σₓ₂^2)
		
		σs[i] = σ_total
	end

	σs_smooth = movmean(σs, window_size)



	fig = Figure()
	ax = Axis(fig[1, 1], xlabel="step", ylabel="posterior L2 norm")

	if use_diff
		σs_diff = diff(σs_smooth)
		lines!(ax, 1:length(σs_diff), movmean(σs_diff, window_size))
	else
		lines!(ax, 1:num_sims, σs_smooth)		
	end

	fig
end

# ╔═╡ 89dcaca2-2f2c-4c85-900d-0bb2869ec205
diff

# ╔═╡ bb94ce77-d48c-4f6d-b282-96197d6e7b6b
md"# Thompson sampling"

# ╔═╡ f55544f3-413d-44c5-8e81-37a5f017b460
md"## Thompson sampling"

# ╔═╡ 76bc6fcb-0018-40dd-9709-65bf9d223615
md"### building overlap functions"

# ╔═╡ 4c2ba203-95c5-4885-88ed-df9f79f12db4
begin
	function overlaps(pos::Vector{Float64}, rect::Rectangle)
	    x, y = pos
	    cx, cy = rect.center
	    hw, hh = rect.width / 2, rect.height / 2
	    return (cx - hw ≤ x ≤ cx + hw) && (cy - hh ≤ y ≤ cy + hh)
	end

	function overlaps(pos::Vector{Float64}, circ::Circle)
	    x, y = pos
	    cx, cy = circ.center
	    return (x - cx)^2 + (y - cy)^2 ≤ circ.radius^2
	end
end

# ╔═╡ ddc23919-17a7-4c78-86f0-226e4d447dbe
	function move!(robot_path::Vector{Vector{Float64}}, direction::Symbol, n::Int; Δx::Float64=Δx, one_step::Bool=false, obstructions::Union{Nothing, Vector{Obstruction}}=nothing, L::Float64=1000.0)
		if one_step
			pos = copy(robot_path[end])
   			Δ = get_Δ(direction; Δx=Δx)

			for _ in 1:n
        		candidate = pos .+ Δ
        		if obstructions !== nothing && any(
						overlaps(
							candidate, obs
						) for obs in obstructions
					)
           	 		break
				elseif any(x -> x <= 0.0 || x >= L, candidate)
					break
        		end
				#need to add logic  to make sure we're not moving off map i.e. candidate can't be greater than L or less than 0
        		pos .= candidate
    		end
			push!(robot_path, pos)
		else
			for i = 1:n
				move!(robot_path, direction, Δx=Δx)
			end
		end
	end

# ╔═╡ 50e623c0-49f6-4bb5-9b15-c0632c3a88fd
begin
	#Δx = 10.0 # m (step length for robot)
	robot_path = [[0.0, 0.0]] # begin at origin
	
	move!(robot_path, :up, 5)
	move!(robot_path, :right, 7)
	move!(robot_path, :up, 10)
	move!(robot_path, :right, 15)
	
	data = DataFrame(
		"time" => 1:length(robot_path),
		"x [m]" => robot_path,
		"counts" => [sample_model(x, test_rad_sim, I=I) for x in robot_path]
	)
end

# ╔═╡ 9fbe820c-7066-40b5-9617-44ae0913928e
viz_data_collection(data, rad_sim=test_rad_sim)

# ╔═╡ e63481a3-a50a-45ae-bb41-9d86c0a2edd0
begin
	#
	prob_model = rad_model(data)
	nb_samples = 4000 # per chain
	nb_chains = 1      # independent chains
	chain = DataFrame(
		sample(prob_model, NUTS(), MCMCSerial(), nb_samples, nb_chains)
	)
end

# ╔═╡ ea2dc60f-0ec1-4371-97f5-bf1e90888bcb
 viz_chain_data(chain)

# ╔═╡ e1303ce3-a8a3-4ac1-8137-52d32bf222e2
P = chain_to_P(chain)

# ╔═╡ bd0a5555-cbe5-42ae-b527-f62cd9eff22f
heatmap(x_bin_centers, x_bin_centers, P)

# ╔═╡ 4bb02313-f48b-463e-a5b6-5b40fba57e81
viz_posterior(chain)

# ╔═╡ f05a7b58-55ac-492c-b0f5-6357cb3e4702
entropy(chain)

# ╔═╡ 7d51a7f2-b0f9-4840-88e4-d5ff8bc2a7d6
data[:, "counts"]

# ╔═╡ adfcd50c-18b4-476a-ae6e-d78cee0eda79
data[:, "counts"]

# ╔═╡ 8b98d613-bf62-4b2e-9bda-14bbf0de6e99
"""
Given the robot path, returns a tuple of optional directions the robot could travel in next.

* `robot_path::Vector{Vector{Float64}}` - the path the robot has taken thus far with the last entry being its current location.
* `L::Float64` - the width/length of the space being explored.
* `Δx::Float64=10.0` - step size of the robot.
* `allow_overlap::Bool=false` - if set to true, allows the robot to backtrack over the previously visited position.
* `obstructions::Union{Nothing, Vector{Obstruction}}=nothing` - vector of obstruction objects, currently only accepting Rectangle and Circle types.
"""
function get_next_steps(
	robot_path::Vector{Vector{Float64}}, 
	L::Float64; 
	Δx::Float64=10.0,
	allow_overlap::Bool=false,
	obstructions::Union{Nothing, Vector{Obstruction}}=nothing
)

	current_pos = robot_path[end]

	directions = Dict(
        :up    => [0.0, Δx],
        :down  => [0.0, -Δx],
        :left  => [-Δx, 0.0],
        :right => [Δx, 0.0]
    )

	last_step = length(robot_path)>1 ? robot_path[end] .- robot_path[end-1] : nothing
	

	function is_valid(dir)
		function unit(v)
		    n = norm(v)
		    n ≈ 0.0 ? v : v ./ n
		end
	    step = directions[dir]
	    new_pos = current_pos .+ step
	    in_bounds = all(0.0 .≤ new_pos .≤ L)
	    dir_unit = unit(step)
	    last_unit = isnothing(last_step) ? dir_unit : unit(last_step)
	    not_backtrack = allow_overlap || isnothing(last_step) || dot(dir_unit, last_unit) > -0.9
	    not_blocked = isnothing(obstructions) || all(obs -> !overlaps(new_pos, obs), obstructions)
	    return in_bounds && not_backtrack && not_blocked
	end

	return Tuple(filter(is_valid, keys(directions)))

end

# ╔═╡ ec9e4693-771c-467d-86cc-ab2ba90019fe
function step_spiral!(
    sc::SpiralController,
	robot_path::Vector{Vector{Float64}};
    Δx::Float64=10.0,
    L::Float64=1000.0,
    allow_overlap::Bool=false,
    obstructions::Union{Nothing, Vector{Obstruction}}=nothing
)
    #gt current direction and step delta
    dir = sc.directions[sc.dir_idx]
    Δ = get_Δ(dir; Δx=Δx)
 	new_pos = sc.pos .+ Δ

	#obstruction or boundary check
    if !isnothing(obstructions)
        blocked = any(obs -> overlaps(new_pos, obs), obstructions) || any(x -> x < 0.0 || x > L, new_pos)
        if blocked
            valid_dirs = get_next_steps([sc.pos], 
										L, 
										Δx=Δx, 
										allow_overlap=allow_overlap, obstructions=obstructions
									   )
            if isempty(valid_dirs)
				push!(robot_path, copy(sc.pos))
                return sc.pos  # stuck, return current position
            else
                new_dir = rand(valid_dirs)
                Δ = get_Δ(new_dir, Δx=Δx)
                new_pos = sc.pos .+ Δ
                sc.pos .= new_pos
				push!(robot_path, copy(sc.pos))
                return new_pos
            end
        end
    end
	

    #step
    sc.pos .= new_pos

    #trck how many steps taken this leg
    sc.leg_count += 1

    #aftr completing a full leg, updte dir
    if sc.leg_count == sc.step_size
        sc.leg_count = 0
        sc.dir_idx = mod1(sc.dir_idx + 1, 4)
        if iseven(sc.dir_idx)  #incr step size every 2 turns
            sc.step_size += sc.step_increment
        end
    end

	push!(robot_path, copy(sc.pos))
    return copy(sc.pos)
end

# ╔═╡ a2154322-23de-49a6-9ee7-2e8e33f8d10c
"""
Given the robot path, finds the best next direction the robot to travel using the infotaxis metrix.

* `robot_path::Vector{Vector{Float64}}` - the path the robot has taken thus far with the last entry being its current location.
* `pr_field::Matrix{Float64}` - current posterior for the source location.
* `chain::DataFrame` - MCMC test data, this will be used feed concentration values from the forward model into a new MCMC test simulations to arrive at a posterior from which we calculate the entropy.
* `num_mcmc_samples::Int64=100` - the number of MCMC samples per simulation.
* `num_mcmc_chains::Int64=1` - the number of chains of MCMC simulations.
* `L::Float64` - the width/length of the space being explored.
* `Δx::Float64=2.0` - step size of the robot.
* `allow_overlap::Bool=false` - allow the algorithm to overlap over previously visited locations, If set to false, it will only visit previously visited locations in the case where it has no other choice.
* `obstructions::Union{Nothing, Vector{Obstruction}}=nothing` - vector of obstruction objects, currently only accepting Rectangle and Circle types.
"""
function thompson_sampling(
	robot_path::Vector{Vector{Float64}}, 
	chain::DataFrame;
	L::Float64=50.0,
	Δx::Float64=2.0,
	allow_overlap::Bool=false,
	obstructions::Union{Nothing, Vector{Obstruction}}=nothing)

	#find direction options from left, right, up, down within domain
	direction_options = get_next_steps(robot_path, L, allow_overlap=allow_overlap, obstructions=obstructions)

	if length(direction_options) < 1 && allow_overlap == true
		@warn "found no viable direction options with overlap allowed, returning nothing"
		return :nothing
	end

	best_direction = :nothing
	greedy_dist = Inf

	#randomly sample from the chain
	rand_θ = chain[rand(1:nrow(chain)), :]
	loc = robot_path[end]

	#loop through direction options and pick the one leading closest to sample
	for direction in direction_options
		new_loc = loc .+ get_Δ(direction)
		dist = norm([rand_θ["x₀[1]"]-new_loc[1], rand_θ["x₀[2]"]-new_loc[2]])
		if dist < greedy_dist
			greedy_dist = dist
			best_direction = direction
		end
	end

	if best_direction == :nothing && allow_overlap == false
		@warn "best direction == nothing, switching to allow overlap"
		return thompson_sampling(
			robot_path, 
			chain,
			L=L,
			Δx=Δx,
			allow_overlap=true,
			obstructions=obstructions)
	end
	
	return best_direction

end

# ╔═╡ ff90c961-70df-478a-9537-5b48a3ccbd5a
md"## simulate source localization"

# ╔═╡ 700b64f7-43d3-461b-bb15-f5905c85e99d
robot_path

# ╔═╡ 52296a3f-9fad-46a8-9894-c84eb5cc86d7
"""
Runs a simulation by placing a robot, calculating a posterior, sampling the posterior using Thompson sampling, then making a single step and repeating `num_steps` times.

* `rad_sim::RadSim` - the radiation simulation RadSim to sample from.
* `num_steps::Int64` - set the max number of steps to simulate movement.
* `robot_start::Vector{Int64}=[0, 0]` - the grid indicies for the robot to start the simulation.
* `num_mcmc_samples::Int64=100` - the number of MCMC samples per simulation.
* `num_mcmc_chains::Int64=1` - the number of chains of MCMC simulations.
* `I::Float64=I` - source strength.
* `L::Float64` - the width/length of the space being explored.
* `Δx::Float64=2.0` - step size of the robot.
* `allow_overlap::Bool=false` - allow the algorithm to overlap over previously visited locations, If set to false, it will only visit previously visited locations in the case where it has no other choice.
* `x₀::Vector{Float64}=[250.0, 250.0]` - source location, this tells the simulation to stop if the current location is within Δx of x₀.
* `save_chains::Bool=false` - set to true to save the MCMC simulation chain data for every step.
* `z_index::Int=1` - sets the current z index of the γ_matrx, for now keep at 1.
* `obstructions::Union{Nothing, Vector{Obstruction}}=nothing` - vector of obstruction objects, currently only accepting Rectangle and Circle types.
"""
function simulate(
	rad_sim::RadSim,
	num_steps::Int64; 
	robot_start::Vector{Int64}=[0, 0], 
	num_mcmc_samples::Int64=150,
	num_mcmc_chains::Int64=4,
	I::Float64=I,
	L::Float64=L,
	Δx::Float64=Δx,
	allow_overlap::Bool=false,
	x₀::Vector{Float64}=[250.0, 250.0],
	save_chains::Bool=false,
	z_index::Int=1,
	obstructions::Union{Nothing, Vector{Obstruction}}=nothing,
	exploring_start::Bool=true,
	num_exploring_start_steps::Int=30,
	spiral::Bool=true,
	r_check::Float64=70.0,
	r_check_count::Int=10,
	meas_time::Float64=1.0
)
	# set up initial position and take measurement
	x_start = [robot_start[i] * Δx for i=1:2]
	c_start = sample_model(x_start, rad_sim, I=I, Δx=Δx, z_index=z_index)

	# data storage
	sim_chains = Dict()
	sim_data = DataFrame(
		"time" => [meas_time],
		"x [m]" => [x_start],
		"counts" => [c_start]
	)
	robot_path = [x_start]

	# exploration parameters
	if spiral
		spiral_control = init_spiral(copy(robot_path[end]), step_init=1, step_incr=2)
	end
	if exploring_start
		expl_start_steps = [num_exploring_start_steps - i >= 1 ? num_exploring_start_steps - i : 1 for i in 0:num_steps-1]
	end
	

	######################################################
	# simulation loop #
	for iter = 1:num_steps
		model = rad_model(sim_data)
		model_chain = DataFrame(
			sample(model, NUTS(), MCMCThreads(), num_mcmc_samples, num_mcmc_chains, progress=false, thin=5)
		)
		#NUTS(100, 0.65, max_depth=7)

		if save_chains
			sim_chains[iter] = model_chain
		end

		#if the source is found, break here
		if norm([robot_path[end][i] - x₀[i] for i=1:2]) <= (2 * Δx^2)^(0.5)
			@info "Source found at step $(iter), robot at location $(robot_path[end])"
			break
		end

		#spiral at the beginning
		if spiral && (iter <= num_exploring_start_steps)

			spiral_step_spacing = 4 * Δx
			new_pos = step_spiral!(spiral_control, 
								   robot_path,
								   Δx=spiral_step_spacing, 
								   L=L, 
								   obstructions=obstructions
								  )
			c_measurement = sample_model(robot_path[end], rad_sim, I=I, Δx=Δx, z_index=z_index)
			Δt_travel = norm(robot_path[end] .- robot_path[end-1]) / r_velocity
			push!(
				sim_data,
				Dict("time" => sim_data[end, "time"] + Δt_travel + meas_time, 
				"x [m]" => robot_path[end], 
				"counts" => c_measurement
				)
			)
		#not spiraling
		else
			# use Thompson sampling to find the best direction
			best_direction = thompson_sampling(
				robot_path, 
				model_chain,
				L=L,
				Δx=Δx,
				allow_overlap=allow_overlap,
				obstructions=obstructions
			)

			#debug code, returns what we have so far in the case of an issue.
			#best_direction shouldn't ever be nothing.
			if best_direction == :nothing
				@warn "iteration $(iter) found best_direction to be :nothing"
				if save_chains
					return sim_data, sim_chains
				else
					return sim_data
				end
			end
	
			# check how many samples takin within r_check radius
			num_within_r_check = sum(
	    		norm(pos .- robot_path[end]) ≤ r_check for pos in robot_path
			)
			# if criteria met, move a lot at once
			if num_within_r_check >= r_check_count
				#move less if counts are high recently
				move_dist = sim_data[iter-1, "counts"] < 2   ? 15 :
				            sim_data[iter-1, "counts"] < 5   ? 10 :
				            sim_data[iter-1, "counts"] < 10  ? 5  :
				            sim_data[iter-1, "counts"] < 30  ? 2  : 1
			else
				move_dist = 1
			end

			#if exploring start, explore first, then adjust movement afterwards
			if exploring_start
			    proposed_dist = expl_start_steps[iter]
			    move_dist = proposed_dist > 1 ? proposed_dist : move_dist
			end
			
			#Move the robot
			move!(
				robot_path, 
				best_direction, 
				move_dist,
      			Δx=Δx, 
				one_step=true, 
				L=L, 
				obstructions=obstructions
			)
			#collect data
			c_measurement = sample_model(robot_path[end], rad_sim, I=I, Δx=Δx, z_index=z_index)
			Δt_travel = norm(robot_path[end] .- robot_path[end-1]) / r_velocity
			push!(
				sim_data,
				Dict("time" => sim_data[end, "time"] + Δt_travel + meas_time, 
				"x [m]" => robot_path[end], 
				"counts" => c_measurement
				)
			)
		end
	end
	# end simulation loop #
	######################################################


	if save_chains
		return sim_data, sim_chains
	else
		return sim_data
	end
end

# ╔═╡ 44d81172-2aef-4ef1-90e9-6a169e92f9ff
md"## `Example Sim`"

# ╔═╡ ae92f6ae-298d-446d-b379-ee2190ef1915
start = [99, 99]

# ╔═╡ ad54d1fa-b3e7-4aeb-96f4-b5d15dee38d5
md"### simulation control"

# ╔═╡ 5c03dc8e-6484-4a73-8cb7-eb43aa382a9d
begin
	# change this to the number of steps you want the robot to take before giving up
	# without obstructions
	num_steps_sim = 15
	#with obstructions
	num_steps_sim_obst = 15

	#num of MCMC chains & samples
	num_mcmc_chain = 4
	num_mcm_sample = 150
	

end

# ╔═╡ f847ac3c-6b3a-44d3-a774-4f4f2c9a195d
simulation_data, simulation_chains = simulate(test_rad_sim, num_steps_sim, save_chains=true, num_mcmc_samples=num_mcm_sample, num_mcmc_chains=num_mcmc_chain, robot_start=start,  exploring_start=true, num_exploring_start_steps=15, spiral=false)

# ╔═╡ c6b9ca97-7e83-4703-abb9-3fd43daeb9a7
viz_sim_chain_entropy(simulation_chains)

# ╔═╡ f063123b-bab8-435c-b128-0dc72d31b5fb
viz_sim_chain_σ(simulation_chains)

# ╔═╡ e7023831-5c03-4f53-95f4-ab837bced1b2
#print(simulation_data)

# ╔═╡ 22a012c1-4169-4959-af47-9d4b01691ae9
#test_rad_sim_obstructed

# ╔═╡ f5ea3486-4930-42c2-af1b-d4a17053976a
@bind chain_val PlutoUI.Slider(1:size(simulation_data, 1)-1, show_value=true)

# ╔═╡ 9a1fa610-054b-4b05-a32b-610f72329166
viz_data_collection(DataFrame(simulation_data[1:chain_val, :]), chain_data=simulation_chains[chain_val],  rad_sim=test_rad_sim)

# ╔═╡ 4a0c8aab-2424-441d-a8c7-9f8076ecbae7
 viz_posterior(simulation_chains[chain_val])

# ╔═╡ 2f7a3d49-1864-4113-b173-ee7e8c9e62a4
md"## `Example Sim` - with obstructions"

# ╔═╡ ef7ff4ec-74ac-40b9-b68b-dbc508e50bef
simulation_data_obst, simulation_chains_obst = simulate(test_rad_sim_obstructed, num_steps_sim_obst, save_chains=true, num_mcmc_samples=num_mcm_sample, num_mcmc_chains=num_mcmc_chain, robot_start=start, obstructions=obstructions, exploring_start=true, spiral=false, num_exploring_start_steps=15)

# ╔═╡ 9d0795fa-703e-47a4-8f1e-fe38b9d604b4
simulation_chains_obst

# ╔═╡ b7673342-70f2-4cbb-869e-1b67f9ee7235
viz_sim_chain_entropy(simulation_chains_obst)

# ╔═╡ 97de1cb8-9c72-440b-896a-a1f1d24e46f5
viz_sim_chain_σ(simulation_chains_obst)

# ╔═╡ 3ff17eaf-974d-4bf0-b75f-d3ef473730bf
begin
	for i=1:length(simulation_chains_obst)
		#viz_data_collection(simulation_data_obst[1:i, :], rad_sim=test_rad_sim_obstructed, obstructions=obstructions, chain_data=simulation_chains_obst[i], save_num=i)
	end
end

# ╔═╡ ea505dc1-a18f-408f-bff8-3b488c49fdb0
@bind chain_val_obst PlutoUI.Slider(1:size(simulation_data_obst, 1)-1, show_value=true)

# ╔═╡ ac2dd9e7-0547-4cda-acf5-845d12d87626
viz_data_collection(simulation_data_obst[1:chain_val_obst, :], rad_sim=test_rad_sim_obstructed, obstructions=obstructions, chain_data=simulation_chains_obst[chain_val_obst])

# ╔═╡ d14fc2b4-ad11-4506-a580-06bfefede40b
 viz_posterior(simulation_chains_obst[chain_val_obst])

# ╔═╡ 4364e9b8-6635-46a6-a556-59d876164a65
data[3, "counts"]

# ╔═╡ a53b3039-eb9e-45aa-914f-034d2a5b6e01
md"# Save sim data"

# ╔═╡ 34527801-4098-4ffe-99c0-5abbdd99ee55
begin
	sim_data = Dict(
		"obstr" => Dict(
			"sim_data" => simulation_data_obst,
			"chains" => simulation_chains_obst
		),
		"no_obstr" => Dict(
			"sim_data" => simulation_data,
			"chains" => simulation_chains
		)
	)

	#save("sim_data_1.jld2", sim_data)
end

# ╔═╡ 40cfe92d-b707-4b22-b3f9-228e5a0df7b2
md"# Batch Test"

# ╔═╡ 0c2d090c-82c8-466d-aea7-140b4422d254
md"## latin hypercube sample starts"

# ╔═╡ 5e5c4e18-63b9-4b2b-bf75-52c77ec3d0fe
"""
Using latin hypercube sampling, generate `num_samples` of pseudo uniformly distributed sample start locations for the robot.

* `num_samples::Int=15` - number of sample start locations.
* `L::Float64=L` - space size.
* `Δx::Float64=Δx` - discretization.
"""
function gen_sample_starts(
	;num_samples::Int=15, 
	L::Float64=L, 
	Δx::Float64=Δx, 
	obstructions::Union{Nothing, Vector{Obstruction}}=nothing
)

	@assert num_samples < 100 "please limit num_samples to less than 100"
	#get latin hypercube samples
	lhc_samples = LHCoptim(num_samples, 2, 10)[1] .* L /num_samples

	#convert to vectors of grid indicies
	r_starts = [(floor(Int, lhc_samples[i, 1] / Δx), 
                 floor(Int, lhc_samples[i, 2] / Δx)) 
                 for i in 1:size(lhc_samples, 1)]

	#if obstructions are provided, check to make sure no overlap occurs
	if !isnothing(obstructions)
		for coords in r_starts
			x₁ = ((coords[1] - 1) * Δx) + 0.5 * Δx
	    	x₂ = ((coords[2] - 1) * Δx) + 0.5 * Δx
			#if overlap is found with obstruction, rerun LHC algorithm
			if !all(obs -> !overlaps([x₁,x₂] , obs), obstructions)
				return gen_sample_starts(num_samples=num_samples, L=L, Δx=Δx, obstructions=obstructions)
			end
		end	
	end

	return r_starts
end

# ╔═╡ fd3393e0-9e08-41e6-a6d2-c28743cb1a68
robot_starts = gen_sample_starts(num_samples=12, obstructions=obstructions)

# ╔═╡ d0875144-8174-4842-ac84-011f6c82f1b1
"""
Simulates the source localization algorithm several times and collects statistical data.
"""
function run_batch(
	rad_sim::RadSim, 
	robot_starts::Vector{Vector{Int64}}; 
	num_mcmc_samples::Int64=150,
	num_mcmc_chains::Int64=4,
	I::Float64=I,
	L::Float64=L,
	Δx::Float64=Δx,
	allow_overlap::Bool=false,
	x₀::Vector{Float64}=[250.0, 250.0],
	z_index::Int=1,
	obstructions::Union{Nothing, Vector{Obstruction}}=nothing,
	exploring_start::Bool=true,
	num_exploring_start_steps::Int=30,
	spiral::Bool=true,
	r_check::Float64=70.0,
	r_check_count::Int=10,
	meas_time::Float64=1.0,
	num_replicates::Int64=5,
	filename::String=batch_1
)
	test_data = Vector{DataFrame}(undef, num_replicates * length(robot_starts))
	max_steps = 400
	for (i, r_start) in enumerate(robot_starts)
		for j=1:num_replicates
			#run simulation
			index = (i - 1) * num_replicates + j
			test_data[index] = simulate(
				rad_sim,
				max_steps,
				robot_start=r_start, 
				num_mcmc_samples=num_mcmc_samples,
				num_mcmc_chains=num_mcmc_chains,
				I=I,
				L=L,
				Δx=Δx,
				allow_overlap=allow_overlap,
				x₀=x₀,
				save_chains=false,
				z_index=z_index,
				obstructions=obstructions,
				exploring_start=exploring_start,
				num_exploring_start_steps=num_exploring_start_steps,
				spiral=spiral,
				r_check=r_check,
				r_check_count=r_check_count,
				meas_time=meas_time
			)
			
		end
	end

	batch_data = Dict("batch" => test_data)
	save("$(filename).jld2", batch_data)
	return test_data
end

# ╔═╡ Cell order:
# ╠═285d575a-ad5d-401b-a8b1-c5325e1d27e9
# ╠═54b50777-cfd7-43a3-bcc2-be47f117e635
# ╟─52d76437-0d60-4589-996f-461eecf0d45d
# ╟─e5b1369e-0b4b-4da3-9c95-07ceda11b31d
# ╠═064eb92e-5ff0-436a-8a2b-4a233ca4fa42
# ╠═b8d6c195-d639-4438-8cab-4dcd99ea2547
# ╟─82577bab-5ce9-4164-84db-9cfa28b501b0
# ╟─a9c65b66-eb92-4943-91a9-9d0ea6cfa3d3
# ╠═57478c44-578e-4b53-b656-c9b3c208dec4
# ╟─03910612-d3fe-481c-bb70-dd5578bd8258
# ╠═dd357479-64ef-4823-8aba-931323e89aed
# ╟─7fcecc0e-f97c-47f7-98db-0da6d6c1811e
# ╟─9ac1e08a-cd89-4afb-92d9-2bd973f06aaa
# ╠═e80af66e-54ab-4661-bd49-89328c17e3d4
# ╠═2c959785-6d71-49c6-921a-16e74cb3b43e
# ╠═0fc694a6-f4cf-478d-bd68-9af5f7f4f5b8
# ╟─181c27f4-6830-4c4d-9392-3237564e6cb1
# ╟─7c44611e-2442-4dca-9624-e18676e0f67c
# ╠═52814746-ae35-4ffa-9be0-66854a4d96bf
# ╠═e62ba8da-663a-4b58-afe6-910710d7518e
# ╠═19c95a83-670c-4ad6-82a1-5a4b6809f1d4
# ╟─8ffaf344-1c74-48c8-a116-8c937322cd6e
# ╠═1197e64f-34c2-4892-8da5-3b26ee6e7c2f
# ╟─7278adb5-2da1-4ea1-aa38-d82c23510242
# ╠═63c8b6dd-d12a-42ec-ab98-1a7c6a991dbd
# ╠═173feaf5-cbfa-4e94-8de5-1a5311cdf14e
# ╠═7211ea6e-6535-4e22-a2ef-a1994e81d22a
# ╠═1f12fcd1-f962-45e9-8c07-4f42f869d6a0
# ╠═bbeed200-3315-4546-9540-16864843f178
# ╟─3ee48a88-3b6a-4995-814b-507679065ff4
# ╠═6fdb31a6-f287-40a4-8c21-2ef92ff90a99
# ╠═ca763f28-d2b2-4eac-ae6c-90f74e3c42e7
# ╠═00f909f7-86fd-4d8e-8db2-6a587ba5f12d
# ╠═5e7dc22c-dc2d-41b0-bb3e-5583a5b79bdd
# ╠═4bda387f-4130-419c-b9a5-73ffdcc184f9
# ╟─560de084-b20b-45d7-816a-c0815f398e6d
# ╠═45014b50-c04b-4f42-83c3-775ec6cd6e3f
# ╠═d47b2021-7129-4a31-8585-2c7257489b1a
# ╟─849ef8ce-4562-4353-8ee5-75d28b1ac929
# ╠═e622cacd-c63f-416a-a4ab-71ba9d593cc8
# ╟─8ed5d321-3992-40db-8a2e-85abc3aaeea0
# ╠═6fa37ac5-fbc2-43c0-9d03-2d194e136951
# ╠═0175ede7-b2ab-4ffd-8da1-278120591027
# ╠═bc761684-699f-430b-bcb9-9b03410fa1d5
# ╠═5b9aaaeb-dbb3-4392-a3a1-ccee94d75fed
# ╟─31864185-6eeb-4260-aa77-c3e94e467558
# ╟─015b9f4d-09b8-49f3-bc03-2fd3b972e933
# ╠═126df6ec-9074-4712-b038-9371ebdbc51d
# ╟─bfe17543-7b54-4f52-9679-f723adafdbdd
# ╠═83052e75-db08-4e0a-8c77-35487c612dae
# ╠═c6c39d74-4620-43df-8eb1-83c436924530
# ╠═3c0f8b63-6276-488c-a376-d5c554a5555d
# ╠═ddc23919-17a7-4c78-86f0-226e4d447dbe
# ╠═50e623c0-49f6-4bb5-9b15-c0632c3a88fd
# ╟─de738002-3e80-4aab-bedb-f08533231ed7
# ╠═deae0547-2d42-4fbc-b3a9-2757fcfecbaa
# ╠═82425768-02ba-4fe3-ab89-9ac95a45e55e
# ╠═9fbe820c-7066-40b5-9617-44ae0913928e
# ╟─50832f87-c7eb-4418-9864-0f807a16e7a7
# ╠═7d0e24e2-de5b-448c-8884-4d407ead1319
# ╠═22652624-e2b7-48e9-bfa4-8a9473568f9d
# ╠═ec9e4693-771c-467d-86cc-ab2ba90019fe
# ╟─3ae4c315-a9fa-48bf-9459-4b7131f5e2eb
# ╟─c6783f2e-d826-490f-93f5-3da7e2717a02
# ╠═1e7e4bad-16a0-40ee-b751-b2f3664f6620
# ╠═e63481a3-a50a-45ae-bb41-9d86c0a2edd0
# ╟─21486862-b3c2-4fcc-98b2-737dcc5211fb
# ╠═2fe974fb-9e0b-4c5c-9a5a-a5c0ce0af065
# ╠═7d51a7f2-b0f9-4840-88e4-d5ff8bc2a7d6
# ╠═0a39daaa-2c20-471d-bee3-dcc06554cf78
# ╠═adfcd50c-18b4-476a-ae6e-d78cee0eda79
# ╠═ea2dc60f-0ec1-4371-97f5-bf1e90888bcb
# ╟─65d603f4-4ef6-4dff-92c1-d6eef535e67e
# ╠═6da11e28-c276-4f45-a1aa-2c86ab26c85a
# ╠═50830491-6285-4915-b59a-fa5bb7298e51
# ╠═065befd1-f652-4925-b1b2-4e847a3884dd
# ╠═e1303ce3-a8a3-4ac1-8137-52d32bf222e2
# ╠═e7567ef6-edaa-4061-9457-b04895a2fca2
# ╠═bd0a5555-cbe5-42ae-b527-f62cd9eff22f
# ╟─aa72cf61-839d-4707-95c8-0a9230e77d56
# ╠═f4d234f9-70af-4a89-9a57-cbc524ec52b4
# ╠═4bb02313-f48b-463e-a5b6-5b40fba57e81
# ╟─95837cad-192d-46b4-aaa4-c86e9b1d1c09
# ╟─8c18d4e8-fd5c-4fd4-8f1e-516615a9e5f0
# ╠═f05a7b58-55ac-492c-b0f5-6357cb3e4702
# ╠═ed8381e3-7a83-4afc-a95d-5cbd03b7e852
# ╟─eafb66bc-6da3-4570-b62a-922627e6ccde
# ╠═9d0795fa-703e-47a4-8f1e-fe38b9d604b4
# ╠═600a5f36-cfa2-4848-8984-44f0ae54ed67
# ╠═b7673342-70f2-4cbb-869e-1b67f9ee7235
# ╠═c6b9ca97-7e83-4703-abb9-3fd43daeb9a7
# ╠═28f9219a-6758-4aa3-8f96-f5b2e8a8e5d7
# ╠═89dcaca2-2f2c-4c85-900d-0bb2869ec205
# ╠═97de1cb8-9c72-440b-896a-a1f1d24e46f5
# ╠═f063123b-bab8-435c-b128-0dc72d31b5fb
# ╟─bb94ce77-d48c-4f6d-b282-96197d6e7b6b
# ╟─f55544f3-413d-44c5-8e81-37a5f017b460
# ╠═a2154322-23de-49a6-9ee7-2e8e33f8d10c
# ╠═76bc6fcb-0018-40dd-9709-65bf9d223615
# ╠═4c2ba203-95c5-4885-88ed-df9f79f12db4
# ╠═8b98d613-bf62-4b2e-9bda-14bbf0de6e99
# ╟─ff90c961-70df-478a-9537-5b48a3ccbd5a
# ╠═700b64f7-43d3-461b-bb15-f5905c85e99d
# ╠═52296a3f-9fad-46a8-9894-c84eb5cc86d7
# ╟─44d81172-2aef-4ef1-90e9-6a169e92f9ff
# ╠═ae92f6ae-298d-446d-b379-ee2190ef1915
# ╟─ad54d1fa-b3e7-4aeb-96f4-b5d15dee38d5
# ╠═5c03dc8e-6484-4a73-8cb7-eb43aa382a9d
# ╠═f847ac3c-6b3a-44d3-a774-4f4f2c9a195d
# ╠═e7023831-5c03-4f53-95f4-ab837bced1b2
# ╠═22a012c1-4169-4959-af47-9d4b01691ae9
# ╠═9a1fa610-054b-4b05-a32b-610f72329166
# ╠═f5ea3486-4930-42c2-af1b-d4a17053976a
# ╠═4a0c8aab-2424-441d-a8c7-9f8076ecbae7
# ╟─2f7a3d49-1864-4113-b173-ee7e8c9e62a4
# ╠═ef7ff4ec-74ac-40b9-b68b-dbc508e50bef
# ╠═ac2dd9e7-0547-4cda-acf5-845d12d87626
# ╠═3ff17eaf-974d-4bf0-b75f-d3ef473730bf
# ╠═ea505dc1-a18f-408f-bff8-3b488c49fdb0
# ╠═d14fc2b4-ad11-4506-a580-06bfefede40b
# ╠═4364e9b8-6635-46a6-a556-59d876164a65
# ╟─a53b3039-eb9e-45aa-914f-034d2a5b6e01
# ╠═34527801-4098-4ffe-99c0-5abbdd99ee55
# ╟─40cfe92d-b707-4b22-b3f9-228e5a0df7b2
# ╟─0c2d090c-82c8-466d-aea7-140b4422d254
# ╠═5e5c4e18-63b9-4b2b-bf75-52c77ec3d0fe
# ╠═fd3393e0-9e08-41e6-a6d2-c28743cb1a68
# ╠═d0875144-8174-4842-ac84-011f6c82f1b1
