module ExperimentSpace
include("Constants.jl")
include("RadModelStructs.jl")
include("InferenceEngine.jl")

using .InferenceEngine, .Constants, .RadModelStructs, LinearAlgebra, Turing, SpecialFunctions, DataFrames, StatsBase, Distributions, JLD2, Logging

#############################################################################
##  NEXT STEP CHECKERS
#############################################################################

"""
Converts a direction to a vector represnetation of movement.

# arguments
* `direction::Symbol` - :up, :down, :left, or :right
# keyword arguments
* `Δx::Float64=Δx` - grid spacing value.
# returns
* `Vector{Float64}` – A 2D vector representing the change in position associated with the given direction. The vector has the form `[Δx, Δy]`, where the magnitude is determined by the `Δx` grid spacing. For example, `:up` returns `[0.0, Δx]`.
"""
function get_Δ(direction::Symbol; Δx::Float64=Δx)
		if direction == :left
			Δ = [-Δx, 0.0]
		elseif direction == :right
			Δ = [Δx, 0.0]
		elseif direction == :up
			Δ = [0.0, Δx]
		elseif direction == :down
			Δ = [0.0, -Δx]
		else
			error("direction not valid")
		end

	return Δ
end


"""
Given the robot path, returns a tuple of optional directions the robot could travel in next.

# arguments
* `robot_path::Vector{Vector{Float64}}` - the path the robot has taken thus far with the last entry being its current location.
* `environment::Environment` - environment struct generated by the `generate_robot_grid_matrix()` function, which should contain a field named grid of type `Array{Union{Bool, Int64}, 3}` where the first two entries are the x and y coordinates of each grid location for the robot search space and the third entry is the matrix of boolean values representing accessibility of locations.
# keyword arguments
* `allow_overlap::Bool=false` - if set to true, allows the robot to backtrack over the previously visited position.
# returns
* `Vector{Symbol}` – A list of direction symbols (`:up`, `:down`, `:left`, `:right`) representing valid next moves for the robot based on the current position, grid boundaries, accessibility, and overlap settings. The directions are filtered to avoid backtracking unless `allow_overlap=true`.
"""
function get_next_steps(
	robot_path::Vector{Vector{Float64}}, 
	environment;
	allow_overlap::Bool=false
)

	#this is needed for src file where type assertions for structs get weird
	@assert hasfield(typeof(environment), :grid) "environment struct, $(environment), must contain the :grid field."

	#ensure equal grid spacing by ensuring equal entries by row for x's, column for y's
	for i=1:size(environment.grid[:, :, 1], 1)
		@assert environment.grid[i, :, 1] == environment.grid[1, :, 1] "row $i is not equal to row 1... all rows must have equal entries."
	end

	for j=1:size(environment.grid[:, :, 1], 2)
		@assert environment.grid[:, j, 2] == environment.grid[:, 1, 2] "column $j is not equal to column 1...($(environment.grid[:, j, 1]) != $(environment.grid[:, 1, 1])) all columns must have equal entries."
	end

	#get indicies that most closely match the current position
	xs 			= environment.grid[1, :, 1]
	ys 			= environment.grid[:, 1, 2]
	current_pos = robot_path[end]
	x_index 	= argmin(abs.(xs .- current_pos[1]))
	y_index 	= argmin(abs.(ys .- current_pos[2]))
	pos_index 	= [x_index, y_index]

	#establish directional index change
	directions 	= Dict(
        :up    => [0, 1],
        :down  => [0, -1],
        :left  => [-1, 0],
        :right => [1, 0]
    )

	prev_pos = length(robot_path)>1 ? robot_path[end-1] : robot_path[end]
	prev_index = [argmin(abs.(xs .- prev_pos[1])), argmin(abs.(ys .- prev_pos[2]))]

	#collect valid directions
	valid_directions = [
        dir for (dir, Δ) in directions 
        if (0 .< (x_index .+ Δ[1]) ≤ size(environment.grid, 1)) &&
           (0 .< (y_index .+ Δ[2]) ≤ size(environment.grid, 2)) &&
           environment.grid[x_index + Δ[1], y_index + Δ[2], 3] == true &&
           (allow_overlap || (x_index + Δ[1], y_index + Δ[2]) != prev_index)
    ]
	return valid_directions
end

#############################################################################
##  THOMPSON SAMPLING
#############################################################################

"""
Given the robot path, finds the best next direction the robot to travel using thompson sampling of the posterior.

# arguments
* `robot_path::Vector{Vector{Float64}}` - the path the robot has taken thus far with the last entry being its current location.
* `environment::Environment` - environment struct generated by the `generate_robot_grid_matrix()` function, which should contain a field named grid of type `Array{Union{Bool, Int64}, 3}` where the first two entries are the x and y coordinates of each grid location for the robot search space and the third entry is the matrix of boolean values representing accessibility of locations.
* `chain::DataFrame` - MCMC test data, this will be used feed concentration values from the forward model into a new MCMC test simulations to arrive at a posterior from which we calculate the entropy.
# keyword arguments
* `allow_overlap::Bool=false` - allow the algorithm to overlap over previously visited locations, If set to false, it will only visit previously visited locations in the case where it has no other choice.
# returns
* `Symbol` – The direction the robot should move next, selected from `:up`, `:down`, `:left`, or `:right` based on the sampled posterior estimate of the source location. If no valid direction is found, returns `:nothing`, or retries with `allow_overlap=true` if not already enabled.
"""
function thompson_sampling(
	robot_path::Vector{Vector{Float64}}, 
	environment,
	chain::DataFrame;
	allow_overlap::Bool=false
)

	#this is needed for src file where type assertions for structs get weird
	@assert hasfield(typeof(environment), :grid) "environment struct, $(environment), must contain the :grid field."

	#find direction options from left, right, up, down within domain
	direction_options = get_next_steps(
		robot_path, 
		environment,
		allow_overlap=allow_overlap
	)

	if length(direction_options) < 1 && allow_overlap == true
		@warn "found no viable direction options with overlap allowed, returning nothing"
		return :nothing
	end
	
	# Direction mappings
    directions = Dict(
        :up    => [0, 1],
        :down  => [0, -1],
        :left  => [-1, 0],
        :right => [1, 0]
    )

	best_direction = :nothing
	greedy_dist = Inf

	#randomly sample from the chain
	rand_θ = chain[rand(1:nrow(chain)), :]
	target = [rand_θ["x₀[1]"], rand_θ["x₀[2]"]]
	loc = robot_path[end]

    # Loop through each valid direction and calculate distance
    for direction in direction_options
        Δ = directions[direction]
        new_location = loc .+ Δ .* environment.Δ  # Apply grid spacing

        # Compute Euclidean distance to the sampled location
        dist = norm(new_location .- target)

        if dist < greedy_dist
            greedy_dist = dist
            best_direction = direction
        end
    end

	#if we can't find any direction at allow and overlap isn't allowed, redo w/ overlap
	if best_direction == :nothing && allow_overlap == false
		@warn "best direction == nothing, switching to allow overlap"
		return thompson_sampling(
			robot_path, 
			environment,
			chain,
			allow_overlap=true
		)
	end
	return best_direction
end

"""
Using Thompson sampling and exploration methods, provide the next location where data should be collected.

# arguments
* `robot_path::Vector{Vector{Float64}}` - the path the robot has taken thus far with the last entry being its current location.
* `environment::Environment` - environment struct generated by the `generate_robot_grid_matrix()` function, which should contain a field named grid of type `Array{Union{Bool, Int64}, 3}` where the first two entries are the x and y coordinates of each grid location for the robot search space and the third entry is the matrix of boolean values representing accessibility of locations.
# keyword arguments
* `num_mcmc_samples::Int64=100` - the number of MCMC samples per simulation.
* `num_mcmc_chains::Int64=1` - the number of chains of MCMC simulations.
* `I::Float64=I` - source strength.
* `allow_overlap::Bool=false` - allow the algorithm to overlap over previously visited locations, If set to false, it will only visit previously visited locations in the case where it has no other choice.
* `x₀::Vector{Float64}=[250.0, 250.0]` - source location, this tells the simulation to stop if the current location is within environment.Δx of x₀.
* `save_chains::Bool=false` - set to true to save the MCMC simulation chain data for every step.
* `exploring_start::Bool=true` - if set to false, will begin by taking single steps only towards the greedy choice from Thompson sampling, otherwise will take decreasingly large steps.
* `num_exploring_start_steps::Int=10` - controls the size and number of exploring start steps. For example, a value of 10 will make the robot take 10 steps initially, followed by 9, then 8 etc...
* `r_check::Float64=70.0` - the radius to check for `r_check_count` number of samples to determine if a large next step should be taken.
* `r_check_count::Int=10` - the number of samples within radius `r_check` to determine if a large next step should be taken.
* `disable_log::Bool=true` - set to false to allow logging by Turing.jl.
# returns
* `Vector{Float64}` – A 2D coordinate `[x, y]` representing the next location where the robot should collect data next. The returned position is chosen based on Thompson sampling from the posterior distribution and adjusted for exploration, while ensuring that the location lies within the accessible search grid and avoids obstructions.

"""
function get_next_sample(
	data::DataFrame, 
	environment;
	num_mcmc_samples::Int64=150,
	num_mcmc_chains::Int64=4,
	I::Float64=I,
	allow_overlap::Bool=false,
	x₀::Vector{Float64}=[250.0, 250.0],
	save_chains::Bool=false,
	exploring_start::Bool=true,
	num_exploring_start_steps::Int=10,
	spiral::Bool=false,
	r_check::Float64=70.0,
	r_check_count::Int=10,
	disable_log::Bool=true,
	turn_off_explore_threshold::Real=5
)
	#this is needed for src file where type assertions for structs get weird
	@assert hasfield(typeof(environment), :grid) "environment struct, $(environment), must contain the :grid field."
	
	#pull robot_path from data
	robot_path = [row["x [m]"] for row in eachrow(data)]

	#get min maxes for search space
	L_min = 1.0 * minimum(environment.grid[:, :, 1:2])
	L_max = 1.0 * maximum(environment.grid[:, :, 1:2])

	#establish Poisson model and calc chains
	model = InferenceEngine.rad_model(data, L_min=L_min, L_max=L_max, environment=environment)
	if disable_log
		Logging.with_logger(NullLogger()) do
			Turing.setprogress!(false)
		model_chain = DataFrame(
			sample(model, NUTS(), MCMCThreads(), num_mcmc_samples, num_mcmc_chains, progress=false)
		)
		end
	else
		model_chain = DataFrame(
			sample(model, NUTS(), MCMCThreads(), num_mcmc_samples, num_mcmc_chains, progress=false)
		)
	end

	#sample posterior and find the next best dir
	next_dir = thompson_sampling(
		robot_path, 
		environment,
		model_chain,
		allow_overlap=allow_overlap
	)

	#establish a single delta, current_pos and
	Δ 			= get_Δ(next_dir, Δx=environment.Δ)
	current_pos = robot_path[end]

	if exploring_start && num_exploring_start_steps - length(robot_path) + 1 > 1
		steps = num_exploring_start_steps - length(robot_path) + 1
	else
		# check how many samples takin within r_check radius
		num_within_r_check = sum(
			norm(pos .- robot_path[end]) ≤ r_check for pos in robot_path
		)
		num_within_r_check -= 1
		# if criteria met, move a lot at once
		steps = num_within_r_check >= r_check_count ? 2 : 1
	end

	#override steps if recent data collection shows high samples
	if data[end, "counts"] > turn_off_explore_threshold
		steps = 1
	end

	#TODO - check from 1 to # steps in next_dir to see if environment.grid[x_coord, y_coord, 3] == true
	for step in 1:steps
        #calc next pos
        next_pos = current_pos .+ step .* Δ
        
        #get grid indicies
        xs = environment.grid[1, :, 1]
        ys = environment.grid[:, 1, 2]
        x_index = argmin(abs.(xs .- next_pos[1]))
        y_index = argmin(abs.(ys .- next_pos[2]))

		#bound check
		if !(0 < x_index ≤ size(environment.grid, 1) && 
			0 < y_index ≤ size(environment.grid, 2))
            @warn "Next position out of bounds. Stopping traversal."
            return save_chains ? (current_pos, model_chain) : current_pos
        end

		#make sure not obstructed
        if !environment.grid[x_index, y_index, 3]
            @warn "Encountered an obstruction at step $(step). Stopping traversal."
            return save_chains ? (current_pos, model_chain) : current_pos
        end

        current_pos = next_pos
    end

	#return final valid pos
	return save_chains ? (current_pos, model_chain) : current_pos
end

#############################################################################
##  SIMULATION
#############################################################################

"""
Runs a source localization simulation in a structured experimental environment defined by a grid.

This function begins at a user-specified grid index within the environment and performs `num_steps` of movement using Thompson sampling-based decision making. It evaluates a probabilistic model at each step, uses MCMC to sample from the posterior, and selects the next location based on sampled target proximity and exploration heuristics. Movement is constrained to accessible grid locations and can optionally avoid previously visited points and obstructions.

# arguments
* `num_steps::Int64` – The number of movement steps the robot should take in the simulation.
* `environment::Environment` – The grid-based environment object. This should contain a field `grid` of type `Array{Union{Bool, Int64}, 3}` with x-coordinates, y-coordinates, and accessibility information.

# keyword arguments
* `robot_start::Vector{Int64}=[41, 43]` – The grid indices (i, j) for the robot's starting location in the environment.
* `num_mcmc_samples::Int64=150` – Number of MCMC samples per inference step.
* `num_mcmc_chains::Int64=4` – Number of MCMC chains to run in parallel.
* `I::Float64=I` – Source strength used in the forward model.
* `allow_overlap::Bool=false` – If `false`, the robot avoids revisiting previously visited locations unless no alternatives exist.
* `x₀::Vector{Float64}=[250.0, 250.0]` – True source location; simulation halts early if the robot comes within `Δx` of this location.
* `save_chains::Bool=false` – If `true`, stores the MCMC chain output at each step for later analysis.
* `exploring_start::Bool=true` – If `true`, the robot starts with large exploratory steps before switching to greedy movement.
* `num_exploring_start_steps::Int=1` – Number of initial large steps before gradually shrinking exploration.
* `spiral::Bool=false` – If `true`, the robot follows a predefined outward spiral pattern at the beginning instead of Thompson sampling.
* `meas_time::Float64=1.0` – Measurement duration per observation.
* `r_check::Float64=70.0` – Radius used to determine local sampling density for adaptive movement scaling.
* `r_check_count::Int=10` – Number of nearby samples within `r_check` required to trigger coarse movement (larger step sizes).
* `disable_log::Bool=true` – If `true`, disables logging output from Turing.jl and MCMC sampling.

# returns
* `sim_data::DataFrame` – A DataFrame containing the simulation results. Each row corresponds to a step in the robot's path and includes the following columns:
  - `"time"` – Cumulative time at each step (including travel and measurement).
  - `"x [m]"` – 2D position of the robot in meters.
  - `"counts"` – Measured radiation counts at each location.

* `sim_chains::Dict{Int, DataFrame}` *(only if `save_chains=true`)* – A dictionary mapping each simulation step index to the corresponding MCMC chain output as a DataFrame. Each chain represents the posterior samples for source location and intensity at that step.
"""
function sim_exp(
    num_steps::Int64,
    environment;
    robot_start::Vector{Int64}=[41, 43],
    num_mcmc_samples::Int64=150,
    num_mcmc_chains::Int64=4,
    I::Float64=I,
    allow_overlap::Bool=false,
    x₀::Vector{Float64}=[250.0, 250.0],
    save_chains::Bool=false,
    exploring_start::Bool=true,
    num_exploring_start_steps::Int=1,
    spiral::Bool=false,
    meas_time::Float64=1.0,
    r_check::Float64=70.0,
    r_check_count::Int=10,
    disable_log::Bool=true
)
    @assert hasfield(typeof(environment), :grid) "environment struct must contain the :grid field."

    # Initialize robot path and starting sample
    x_start = 1.0 * environment.grid[robot_start[2], robot_start[1], 1]
    y_start = 1.0 * environment.grid[robot_start[2], robot_start[1], 2]
    robot_path = [[x_start, y_start]]

    sample_mean = mean(count_Poisson(robot_path[end], x₀, I))
    noise = rand(Poisson(0.5)) * rand([-1, 1])
    start_sample = round(Int, max(sample_mean + noise, 0))

    sim_data = DataFrame(
        "time" => [meas_time],
        "x [m]" => [robot_path[end]],
        "counts" => [start_sample]
    )
    sim_chains = Dict{Int, DataFrame}()

    for step = 1:num_steps

        result = get_next_sample(
            sim_data,
            environment;
            num_mcmc_samples=num_mcmc_samples,
            num_mcmc_chains=num_mcmc_chains,
            I=I,
            allow_overlap=allow_overlap,
            x₀=x₀,
            save_chains=save_chains,
            exploring_start=exploring_start,
            num_exploring_start_steps=num_exploring_start_steps,
            spiral=spiral,
            r_check=r_check,
            r_check_count=r_check_count,
            disable_log=disable_log
        )

		if norm(robot_path[end] .- x₀) <= (2 * environment.Δ^2)^(0.5)
            @info "Source found at step $(step), robot at location $(robot_path[end])"
			sim_chains[step] = result[2]
            break
        end

	if save_chains
		if result isa Tuple{Vector{Float64}, DataFrame}
			next_pos, model_chain = result
			sim_chains[step] = model_chain
		else
			@warn "Expected tuple return but got $(typeof(result)). Using result as next_pos."
			next_pos = result
		end
	else
		next_pos = result
	end

        Δt_travel = norm(next_pos .- robot_path[end]) / r_velocity
        robot_path = push!(robot_path, next_pos)

        sample_mean = mean(count_Poisson(next_pos, x₀, I))
        noise = rand(Poisson(λ_background)) * rand([-1, 1])
        counts = round(Int, max(sample_mean + noise, 0))

        push!(sim_data, Dict(
            "time" => sim_data[end, "time"] + Δt_travel + meas_time,
            "x [m]" => next_pos,
            "counts" => counts
        ))
    end

    return save_chains ? (sim_data, sim_chains) : sim_data
end

end