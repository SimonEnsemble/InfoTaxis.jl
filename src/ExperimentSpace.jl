module ExperimentSpace
include("Constants.jl")
include("RadModelStructs.jl")
include("InferenceEngine.jl")

using .InferenceEngine, .Constants, .RadModelStructs, LinearAlgebra, Turing, SpecialFunctions, DataFrames, StatsBase, Distributions, JLD2, Logging

#############################################################################
##  NEXT STEP CHECKERS
#############################################################################

"""
Converts a direction to a vector represnetation of movement.

# arguments
* `direction::Symbol` - :up, :down, :left, or :right
# keyword arguments
* `Δx::Float64=Δx` - grid spacing value.
# returns
* `Vector{Float64}` – A 2D vector representing the change in position associated with the given direction. The vector has the form `[Δx, Δy]`, where the magnitude is determined by the `Δx` grid spacing. For example, `:up` returns `[0.0, Δx]`.
"""
function get_Δ(direction::Symbol; Δx::Float64=Δx)
		if direction == :left
			Δ = [-Δx, 0.0]
		elseif direction == :right
			Δ = [Δx, 0.0]
		elseif direction == :up
			Δ = [0.0, Δx]
		elseif direction == :down
			Δ = [0.0, -Δx]
		else
			error("direction not valid")
		end

	return Δ
end


"""
Given the robot path, returns a tuple of optional directions the robot could travel in next.

# arguments
* `robot_path::Vector{Vector{Float64}}` - the path the robot has taken thus far with the last entry being its current location.
* `environment::Environment` - environment struct generated by the `generate_robot_grid_matrix()` function, which should contain a field named grid of type `Array{Union{Bool, Int64}, 3}` where the first two entries are the x and y coordinates of each grid location for the robot search space and the third entry is the matrix of boolean values representing accessibility of locations.
# keyword arguments
* `allow_overlap::Bool=false` - if set to true, allows the robot to backtrack over the previously visited position.
# returns
* `Vector{Symbol}` – A list of direction symbols (`:up`, `:down`, `:left`, `:right`) representing valid next moves for the robot based on the current position, grid boundaries, accessibility, and overlap settings. The directions are filtered to avoid backtracking unless `allow_overlap=true`.
"""
function get_next_steps(
	robot_path::Vector{Vector{Float64}}, 
	environment;
	allow_overlap::Bool=false
)

	#this is needed for src file where type assertions for structs get weird
	@assert hasfield(typeof(environment), :grid) "environment struct, $(environment), must contain the :grid field."

	#ensure equal grid spacing by ensuring equal entries by row for x's, column for y's
	for i=1:size(environment.grid[:, :, 1], 1)
		@assert environment.grid[i, :, 1] == environment.grid[1, :, 1] "row $i is not equal to row 1... all rows must have equal entries."
	end

	for j=1:size(environment.grid[:, :, 1], 2)
		@assert environment.grid[:, j, 2] == environment.grid[:, 1, 2] "column $j is not equal to column 1...($(environment.grid[:, j, 1]) != $(environment.grid[:, 1, 1])) all columns must have equal entries."
	end

	#get indicies that most closely match the current position
	xs 			= environment.grid[1, :, 1]
	ys 			= environment.grid[:, 1, 2]
	current_pos = robot_path[end]
	x_index 	= argmin(abs.(xs .- current_pos[1]))
	y_index 	= argmin(abs.(ys .- current_pos[2]))
	pos_index 	= [x_index, y_index]

	#establish directional index change
	directions 	= Dict(
        :up    => [0, 1],
        :down  => [0, -1],
        :left  => [-1, 0],
        :right => [1, 0]
    )

	prev_pos = length(robot_path)>1 ? robot_path[end-1] : robot_path[end]
	prev_index = [argmin(abs.(xs .- prev_pos[1])), argmin(abs.(ys .- prev_pos[2]))]

	#collect valid directions
	valid_directions = [
        dir for (dir, Δ) in directions 
        if (0 .< (x_index .+ Δ[1]) ≤ size(environment.grid, 1)) &&
           (0 .< (y_index .+ Δ[2]) ≤ size(environment.grid, 2)) &&
           environment.grid[x_index + Δ[1], y_index + Δ[2], 3] == true &&
           (allow_overlap || (x_index + Δ[1], y_index + Δ[2]) != prev_index)
    ]
	return valid_directions
end

#############################################################################
##  THOMPSON SAMPLING
#############################################################################

"""
Given the robot path, finds the best next direction the robot to travel using thompson sampling of the posterior.

# arguments
* `robot_path::Vector{Vector{Float64}}` - the path the robot has taken thus far with the last entry being its current location.
* `environment::Environment` - environment struct generated by the `generate_robot_grid_matrix()` function, which should contain a field named grid of type `Array{Union{Bool, Int64}, 3}` where the first two entries are the x and y coordinates of each grid location for the robot search space and the third entry is the matrix of boolean values representing accessibility of locations.
* `chain::DataFrame` - MCMC test data, this will be used feed concentration values from the forward model into a new MCMC test simulations to arrive at a posterior from which we calculate the entropy.
# keyword arguments
* `allow_overlap::Bool=false` - allow the algorithm to overlap over previously visited locations, If set to false, it will only visit previously visited locations in the case where it has no other choice.
# returns
* `Symbol` – The direction the robot should move next, selected from `:up`, `:down`, `:left`, or `:right` based on the sampled posterior estimate of the source location. If no valid direction is found, returns `:nothing`, or retries with `allow_overlap=true` if not already enabled.
"""
function thompson_sampling(
	robot_path::Vector{Vector{Float64}}, 
	environment,
	chain::DataFrame;
	allow_overlap::Bool=false
)

	#this is needed for src file where type assertions for structs get weird
	@assert hasfield(typeof(environment), :grid) "environment struct, $(environment), must contain the :grid field."

	#find direction options from left, right, up, down within domain
	direction_options = get_next_steps(
		robot_path, 
		environment,
		allow_overlap=allow_overlap
	)

	if length(direction_options) < 1 && allow_overlap == true
		@warn "found no viable direction options with overlap allowed, returning nothing"
		return :nothing
	end
	
	# Direction mappings
    directions = Dict(
        :up    => [0, 1],
        :down  => [0, -1],
        :left  => [-1, 0],
        :right => [1, 0]
    )

	best_direction = :nothing
	greedy_dist = Inf

	#randomly sample from the chain
	rand_θ = chain[rand(1:nrow(chain)), :]
	target = [rand_θ["x₀[1]"], rand_θ["x₀[2]"]]
	loc = robot_path[end]

    # Loop through each valid direction and calculate distance
    for direction in direction_options
        Δ = directions[direction]
        new_location = loc .+ Δ .* environment.Δ  # Apply grid spacing

        # Compute Euclidean distance to the sampled location
        dist = norm(new_location .- target)

        if dist < greedy_dist
            greedy_dist = dist
            best_direction = direction
        end
    end

	#if we can't find any direction at allow and overlap isn't allowed, redo w/ overlap
	if best_direction == :nothing && allow_overlap == false
		@warn "best direction == nothing, switching to allow overlap"
		return thompson_sampling(
			robot_path, 
			environment,
			chain,
			allow_overlap=true
		)
	end
	return best_direction
end

"""
Using Thompson sampling and exploration methods, provide the next location where data should be collected.

# arguments
* `robot_path::Vector{Vector{Float64}}` - the path the robot has taken thus far with the last entry being its current location.
* `environment::Environment` - environment struct generated by the `generate_robot_grid_matrix()` function, which should contain a field named grid of type `Array{Union{Bool, Int64}, 3}` where the first two entries are the x and y coordinates of each grid location for the robot search space and the third entry is the matrix of boolean values representing accessibility of locations.
# keyword arguments
* `num_mcmc_samples::Int64=100` - the number of MCMC samples per simulation.
* `num_mcmc_chains::Int64=1` - the number of chains of MCMC simulations.
* `I::Float64=I` - source strength.
* `allow_overlap::Bool=false` - allow the algorithm to overlap over previously visited locations, If set to false, it will only visit previously visited locations in the case where it has no other choice.
* `x₀::Vector{Float64}=[250.0, 250.0]` - source location, this tells the simulation to stop if the current location is within environment.Δx of x₀.
* `save_chains::Bool=false` - set to true to save the MCMC simulation chain data for every step.
* `exploring_start::Bool=true` - if set to false, will begin by taking single steps only towards the greedy choice from Thompson sampling, otherwise will take decreasingly large steps.
* `num_exploring_start_steps::Int=10` - controls the size and number of exploring start steps. For example, a value of 10 will make the robot take 10 steps initially, followed by 9, then 8 etc...
* `r_check::Float64=70.0` - the radius to check for `r_check_count` number of samples to determine if a large next step should be taken.
* `r_check_count::Int=10` - the number of samples within radius `r_check` to determine if a large next step should be taken.
* `disable_log::Bool=true` - set to false to allow logging by Turing.jl.
# returns
* `Vector{Float64}` – A 2D coordinate `[x, y]` representing the next location where the robot should collect data. The returned position is chosen based on Thompson sampling from the posterior distribution and adjusted for exploration, while ensuring that the location lies within the accessible search grid and avoids obstructions.

"""
function get_next_sample(
	data::DataFrame, 
	environment;
	num_mcmc_samples::Int64=150,
	num_mcmc_chains::Int64=4,
	I::Float64=Constants.I,
	allow_overlap::Bool=false,
	x₀::Vector{Float64}=[250.0, 250.0],
	save_chains::Bool=false,
	exploring_start::Bool=true,
	num_exploring_start_steps::Int=10,
	spiral::Bool=false,
	r_check::Float64=70.0,
	r_check_count::Int=10,
	disable_log::Bool=true
)
	#this is needed for src file where type assertions for structs get weird
	@assert hasfield(typeof(environment), :grid) "environment struct, $(environment), must contain the :grid field."

	#pull robot_path from data
	robot_path = [row["x [m]"] for row in eachrow(data)]

	#establish Poisson model and calc chains
	model = rad_model(data)
	if disable_log
		Turing.setprogress!(false)
		Logging.with_logger(NullLogger()) do
		model_chain = DataFrame(
			sample(model, NUTS(), MCMCThreads(), num_mcmc_samples, num_mcmc_chains, progress=false, thin=5)
		)
		end
	else
		model_chain = DataFrame(
			sample(model, NUTS(), MCMCThreads(), num_mcmc_samples, num_mcmc_chains, progress=false, thin=5)
		)
	end

	#sample posterior and find the next best dir
	next_dir = thompson_sampling(
		robot_path, 
		environment,
		model_chain,
		allow_overlap=allow_overlap
	)

	#establish a single delta, current_pos and
	Δ 			= get_Δ(next_dir, Δx=environment.Δ)
	current_pos = robot_path[end]

	if exploring_start && num_exploring_start_steps - length(robot_path) + 1 > 1
		steps = num_exploring_start_steps - length(robot_path) + 1
	else
		# check how many samples takin within r_check radius
		num_within_r_check = sum(
			norm(pos .- robot_path[end]) ≤ r_check for pos in robot_path
		)
		num_within_r_check -= 1
		# if criteria met, move a lot at once
		steps = num_within_r_check >= r_check_count ? 3 : 1
	end

	#TODO - check from 1 to # steps in next_dir to see if environment.grid[x_coord, y_coord, 3] == true
	for step in 1:steps
        #calc next pos
        next_pos = current_pos .+ step .* Δ
        
        #get grid indicies
        xs = environment.grid[1, :, 1]
        ys = environment.grid[:, 1, 2]
        x_index = argmin(abs.(xs .- next_pos[1]))
        y_index = argmin(abs.(ys .- next_pos[2]))

		#bound check
		if !(0 < x_index ≤ size(environment.grid, 1) && 
			0 < y_index ≤ size(environment.grid, 2))
            @warn "Next position out of bounds. Stopping traversal."
            return current_pos
        end

		#make sure not obstructed
        if !environment.grid[x_index, y_index, 3]
            @warn "Encountered an obstruction at step $(step). Stopping traversal."
            return current_pos
        end

        current_pos = next_pos
    end

	#return final valid pos
    return current_pos
end

end