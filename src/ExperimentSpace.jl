module ExperimentSpace
include("Constants.jl")
include("RadModelStructs.jl")
include("InferenceEngine.jl")

using .InferenceEngine, .Constants, .RadModelStructs, LinearAlgebra, Turing, SpecialFunctions, DataFrames, StatsBase, Distributions, JLD2, Logging

#############################################################################
##  NEXT STEP CHECKERS
#############################################################################


"""
Given the robot path, returns a tuple of optional directions the robot could travel in next.

* `robot_path::Vector{Vector{Float64}}` - the path the robot has taken thus far with the last entry being its current location.
* `environment::Environment` - environment struct generated by the `generate_robot_grid_matrix()` function, which should contain a field named grid of type `Array{Union{Bool, Int64}, 3}` where the first two entries are the x and y coordinates of each grid location for the robot search space and the third entry is the matrix of boolean values representing accessibility of locations.
* `allow_overlap::Bool=false` - if set to true, allows the robot to backtrack over the previously visited position.
"""
function get_next_steps(
	robot_path::Vector{Vector{Float64}}, 
	environment::Environment;
	allow_overlap::Bool=false
)

	#this is needed for src file where type assertions for structs get weird
	@assert hasfield(typeof(environment), :grid) "environment struct, $(environment), must contain the :grid field."

	#ensure equal grid spacing by ensuring equal entries by row for x's, column for y's
	for i=1:size(environment.grid[:, :, 1], 1)
		@assert environment.grid[i, :, 1] == environment.grid[1, :, 1] "row $i is not equal to row 1... all rows must have equal entries."
	end

	for j=1:size(environment.grid[:, :, 1], 2)
		@assert environment.grid[:, j, 1] == environment.grid[:, 1, 1] "column $j is not equal to column 1... all columns must have equal entries."
	end

	#get indicies that most closely match the current position
	xs 			= environment.grid[1, :, 1]
	ys 			= environment.grid[:, 1, 2]
	current_pos = robot_path[end]
	x_index 	= argmin(abs.(xs .- current_pos[1]))
	y_index 	= argmin(abs.(ys .- current_pos[2]))
	pos_index 	= [x_index, y_index]

	#establish directional index change
	directions 	= Dict(
        :up    => [0, 1],
        :down  => [0, -1],
        :left  => [-1, 0],
        :right => [1, 0]
    )

	prev_pos = length(robot_path)>1 ? robot_path[end-1] : robot_path[end]
	prev_index = [argmin(abs.(xs .- prev_pos[1])), argmin(abs.(ys .- prev_pos[2]))]

	#collect valid directions
	valid_directions = [
        dir for (dir, Δ) in directions 
        if (0 .< (x_index .+ Δ[1]) ≤ size(environment.grid, 1)) &&
           (0 .< (y_index .+ Δ[2]) ≤ size(environment.grid, 2)) &&
           environment.grid[x_index + Δ[1], y_index + Δ[2], 3] == true &&
           (allow_overlap || (x_index + Δ[1], y_index + Δ[2]) != prev_index)
    ]
	return valid_directions
end

#############################################################################
##  THOMPSON SAMPLING
#############################################################################

"""
Given the robot path, finds the best next direction the robot to travel using Thompson sampling of the posterior.

* `robot_path::Vector{Vector{Float64}}` - the path the robot has taken thus far with the last entry being its current location.
* `environment::Environment` - environment struct generated by the `generate_robot_grid_matrix()` function, which should contain a field named grid of type `Array{Union{Bool, Int64}, 3}` where the first two entries are the x and y coordinates of each grid location for the robot search space and the third entry is the matrix of boolean values representing accessibility of locations.
* `chain::DataFrame` - MCMC test data, this will be used feed concentration values from the forward model into a new MCMC test simulations to arrive at a posterior from which we calculate the entropy.
* `allow_overlap::Bool=false` - allow the algorithm to overlap over previously visited locations, If set to false, it will only visit previously visited locations in the case where it has no other choice.
"""
function thompson_sampling(
	robot_path::Vector{Vector{Float64}}, 
	environment::Environment,
	chain::DataFrame;
	allow_overlap::Bool=false
)

	#find direction options from left, right, up, down within domain
	direction_options = get_next_steps(
		robot_path, 
		environment,
		allow_overlap=allow_overlap
	)

	if length(direction_options) < 1 && allow_overlap == true
		@warn "found no viable direction options with overlap allowed, returning nothing"
		return :nothing
	end
	
	# Direction mappings
    directions = Dict(
        :up    => [0, 1],
        :down  => [0, -1],
        :left  => [-1, 0],
        :right => [1, 0]
    )

	best_direction = :nothing
	greedy_dist = Inf

	#randomly sample from the chain
	rand_θ = chain[rand(1:nrow(chain)), :]
	target = [rand_θ["x₀[1]"], rand_θ["x₀[2]"]]
	loc = robot_path[end]

    # Loop through each valid direction and calculate distance
    for direction in direction_options
        Δ = directions[direction]
        new_location = loc .+ Δ .* environment.Δ  # Apply grid spacing

        # Compute Euclidean distance to the sampled location
        dist = norm(new_location .- target)

        if dist < greedy_dist
            greedy_dist = dist
            best_direction = direction
        end
    end

	#if we can't find any direction at allow and overlap isn't allowed, redo w/ overlap
	if best_direction == :nothing && allow_overlap == false
		@warn "best direction == nothing, switching to allow overlap"
		return thompson_sampling(
			robot_path, 
			environment,
			chain,
			allow_overlap=true
		)
	end
	
	return best_direction

end
end