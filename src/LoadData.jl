module LoadData

RadModelStructs = include("RadModelStructs.jl")

using .RadModelStructs, LinearAlgebra, SpecialFunctions, DataFrames, StatsBase, Distributions, JLD2, CSV, DelimitedFiles


#############################################################################
##  IMPORT VACUUM ROBOT DATA
#############################################################################

"""
Function to read csv file generated by the rad teams python script. This will take the python CSV file, remove extraneous characters, turn it into a matrix of 1's and 0's and orient it properly. The 1's in the matrix represent known obstructions or walls and the 0's represent empty space. Each index of the matrix represents a centimeter as interpreted by the vacuum robot.

# arguments
* `path::String` - the path to the csv file we want to convert to a matrix.
# returns
* `Matrix{Int}` – A square matrix of `1`s and `0`s where:
  - `1` represents an obstruction (e.g., a wall or object),
  - `0` represents free space.
The matrix is reoriented such that the vertical axis is flipped to match the expected coordinate system for the environment, with each index corresponding to a 1 cm × 1 cm grid cell.
"""
function parse_numpy_csv_file(path::String)
    raw = read(path, String)

    stripped = replace(raw, ['[', ']', '"', '\n', '.'] => "")
    tokens = split(strip(stripped))
    values = round.(Int, parse.(Float64, tokens))

    #check if it's a perfect square
    n = length(values)
    ncols = Int(round(sqrt(n)))
    @assert ncols^2 == n "Matrix is not square: total elements = $n, but sqrt = $ncols"

    #reshape into square matrix
	square_matrix = reshape(values, ncols, ncols)

	#flip y axis
	square_matrix_flipped = square_matrix[:, end:-1:1]
	
    return square_matrix_flipped
end


"""
Loads a CSV file containing raw sensor data from the vacuum robot, removes the header, and standardizes the format to match internal data structures.

# arguments
* `data_path::String`: Path to the CSV file. The file is expected to have a header row followed by columns representing time, x-position, y-position, and count measurements.

# returns
* `DataFrame`: A standardized DataFrame with the following columns:
  * `"time"`: Time of measurement (from column 1 of the CSV).
  * `"x [m]"`: A 2-element vector `[x, y]` of spatial coordinates (from columns 2 and 3).
  * `"counts"`: Measurement count rounded to the nearest integer (from column 4).
"""
function load_and_standardize_data_from_csv(data_path::String)
    #load CSV, skipping the first header row
    raw_df = CSV.read(data_path, DataFrame; header=false, skipto=2)

    #standardized DataFrame
    df = DataFrame(
        "time" => raw_df[:, 1],
        "x [m]" => [ [x, y] for (x, y) in zip(raw_df[:, 2], raw_df[:, 3]) ],
        "counts" => round.(Int, raw_df[:, 4])
    )

    return df
end


"""
Identifies points that are too close (i.e. within radius) of a wall. This is being used to thicken walls for the flood fill algorithm.

# arguments
* `env_matrix::Matrix{Int}` - the environment matrix generated by the vacuum robot containing 0's for opent space and 1's for obstructions.
* `radius::Int` - the degree to which we want to thicken the wall, for a value of 0 this will simply return the original env_matrix. Larger values will create thicker walls.
"""
function clearance_mask(env::Matrix{Int}, radius::Int)
    h, w = size(env)
    mask = falses(h, w)

    for y in 1:h, x in 1:w
        for dy in -radius:radius, dx in -radius:radius
            yy, xx = y + dy, x + dx
			#check if the current grid location is too close to an obstacle
            if xx ≥ 1 && xx ≤ w && yy ≥ 1 && yy ≤ h && env[yy, xx] == 1
                mask[y, x] = true
                break
            end
        end
    end

    return mask
end

"""
Breadth first search flood fill (paint bucket) algorithm. Finds adjacent locations that are accessible from a seed location and returns a new matrix excluding locations that cannot be accessed from the seed by traveling adjacently.

# arguments
* `env::Matrix{Int}` - Matrix containing only 0's and 1's, where a 0 represents open space and a 1 represents an obstruction.
* `seed::Tuple{Int, Int}` - The starting location (indicies) for the paint bucket, this index must point to a 0 such that `env[seed]==0`.
# keyword arguments
* `clearance_radius::Int=5` - The thickness of walls, larger values will ensure small openings are blocked, set to 0 to not use a mask at all.
"""
function flood_fill(
	env::Matrix{Int}, 
	seed::Tuple{Int, Int}; 
	clearance_radius::Int=5
)
    h, w = size(env)
    buffer_zone = clearance_mask(env, clearance_radius)
    visited = falses(h, w)

	#check seed validity
    x₀, y₀ = seed
    if env[y₀, x₀] != 0 || buffer_zone[y₀, x₀]
        error("Seed is not in valid, clear space")
    end

	#initialize q as the seed location
    q = [(x₀, y₀)]

	#flood fill algorithm, builds out from the seed until it runs into the buffer_zone
    while !isempty(q)
        (x, y) = pop!(q)

        if x < 1 || x > w || y < 1 || y > h
            continue
        elseif visited[y, x] || env[y, x] != 0 || buffer_zone[y, x]
            continue
        end

        visited[y, x] = true
        append!(q, [(x+1, y), (x-1, y), (x, y+1), (x, y-1)])
    end

	#remake environment as 0's and 1's
    new_env = copy(env)
    for y in 1:h, x in 1:w
        if env[y, x] == 0 && !visited[y, x]
            new_env[y, x] = 1
        end
    end

    return new_env
end

"""
Generates a matrix of locations for a robot to explore of user defined coarseness.

# arguments
* `environment::Matrix{Int}` - Matrix containing only 0's and 1's, where a 0 represents open space and a 1 represents an obstruction.
* `step::Int` - The size of each step in the robot exploration matrix. For example, a step of 10 means each index in the robot matrix is 10 times further apart then the original obstruction map.
# keyword arguments
* `mask_outside::Bool=true` - set to true to use flood fill algorithm (paint bucket) to try and remove inaccessible sections of the map.
* `seed::Tuple{Int, Int}=(250,250)` - The starting location (indicies) for the paint bucket, this index must point to a 0 such that `env[seed]==0`.
* `clearance_radius::Int=5` - adjusts the clearance radius of the mask, i.e. thickens the walls.
# returns
* `Environment` – A structured environment object containing:
  - `env::Matrix{Int}` – The original input environment matrix.
  - `masked_env::Matrix{Int}` – The environment after optional flood fill masking (if `mask_outside=true`).
  - `grid::Array{Union{Int, Bool}, 3}` – A 3D array representing the robot's coarser sampling grid:
    - `grid[:, :, 1]` – x-coordinates in the original environment,
    - `grid[:, :, 2]` – y-coordinates in the original environment,
    - `grid[:, :, 3]` – boolean values indicating accessibility at each coarse location.
  - `Δ::Float64` – The spatial resolution (in meters) corresponding to `step`.

"""
function generate_robot_grid_matrix(
	environment::Matrix{Int}, 
	step::Int; 
	mask_outside::Bool=true, 
	seed::Tuple{Int, Int}=(250,250), 
	clearance_radius::Int=5
)
    h, w = size(environment)

    # Optionally apply flood fill to exclude disconnected regions
    if mask_outside
        environment_masked = Int.(flood_fill(environment, 
									  seed, 
									  clearance_radius=clearance_radius
									 )
						  )
	else
		environment_masked = environment
    end
    grid_rows = cld(h, step)
    grid_cols = cld(w, step)

    #grid is made of x, y coordinates of original robot space and boolean to represent accessibility
    grid = Array{Union{Int, Bool}}(undef, grid_rows, grid_cols, 3)

    for i in 1:grid_rows
        for j in 1:grid_cols
            y = min((i - 1) * step + 1, h)
            x = min((j - 1) * step + 1, w)
            valid = environment_masked[y, x] == 0
            grid[i, j, 1] = x
            grid[i, j, 2] = y
            grid[i, j, 3] = valid
        end
    end

	#store everything in data struct
	env = Environment(
		environment,
		environment_masked,
		grid,
		step*1.0
	)

    return env
end


#############################################################################
##  IMPORT DR. YANG'S MODEL DATA
#############################################################################
"""
Reads the lines of the simulation data file provided by the radiation team at path: `data_file_path::String` and returns a RadSim data struct.

# arguments
* `data_file_path::String` - the path to the simulation data file.
# keyword arguments
* `x₀::Vector{Float64}=[250.0, 250.0]` - the coordinates of the source, this will be stored in the data structure returned by `import_data`.
# returns
* `RadSim` – A radiation simulation data structure containing:
  - `γ_matrix::Vector{Matrix{Float64}}` – A list of 2D matrices (one per z-slice) representing radiation interaction data.
  - `Δxy::Float64` – Spatial resolution in the x-y plane.
  - `Δz::Float64` – Spatial resolution along the z-axis.
  - `Lxy::Float64` – Side length (in meters) of the square x-y plane.
  - `Lz::Float64` – Total height (in meters) along the z-axis.
  - `x₀::Vector{Float64}` – The specified source location used in simulation.
"""
function import_data(data_file_path::String; x₀::Vector{Float64}=[250.0, 250.0])
	#ensure the input is a file.
	@assert isfile(data_file_path) "$(data_file_path) is not a file!!!"

	#flags used to indicate sections of the data file.
	flags = Dict(
		"tally_bin_bounds" => false,
		"x_dir" => false,
		"y_dir" => false,
		"z_dir" => false,
		"energy_grid" => false
	)

	#set up a dictionary to hold the data
	data = Dict(
		"x_bin_bounds" => Array{Float64}(undef, 0),
		"y_bin_bounds" => Array{Float64}(undef, 0),
		"z_bin_bounds" => Array{Float64}(undef, 0),
		"energy_field_data" => DataFrame(
			Energy = Array{Float64}(undef, 0),
			X = Array{Float64}(undef, 0),
			Y = Array{Float64}(undef, 0),
			Z = Array{Float64}(undef, 0),
			Result = Array{Float64}(undef, 0),
			RelError = Array{Float64}(undef, 0)
		)
	)

	#read the rad sim file line by line
	open(data_file_path) do f
		while !eof(f)
			#read the line
			f_line = lowercase(readline(f))
			# replace double+ spaces with single spaces
			s = replace(f_line, r"\s{2,}" => " ")

			#check for first line of data
			#there are two main sections, "tally bin boundaries" and "energy x y"
			if contains(s, "tally bin boundaries")
				flags["tally_bin_bounds"] = true
				continue
			elseif contains(s, "energy x y")
				flags["energy_grid"] = true
				continue
			end

			#tally bin bounds section
			#within this section we use the x, y, z direction flags
			if flags["tally_bin_bounds"]
				#if we reach the next section, turn off the flag and continue
				if contains(s, "energy bin boundaries")
					flags["tally_bin_bounds"] = false
					continue
				end
   				for dir in ["x", "y", "z"]
					#check if the beginning of a new direction
        			if occursin("$dir direction", s)
            			flags["x_dir"] = flags["y_dir"] = flags["z_dir"] = false
           				flags["$(dir)_dir"] = true
						
						values = parse.(Float64, split(s)[3:end])
						data["$(dir)_bin_bounds"] = values
					#if not the beginning of a new direction, collect data
					elseif !(occursin("direction", s))
						#only collect data for the current flagged direction
						if flags["$(dir)_dir"]
							values = parse.(Float64, split(s))
							data["$(dir)_bin_bounds"] = vcat(data["$(dir)_bin_bounds"], values)
						end
					end
				end
			end
			#for engery_grid, just push new lines to the dataframe
			if flags["energy_grid"]
				values = parse.(Float64, split(s))
				push!(data["energy_field_data"], values)
			end
		end
	end

	#convert data into a matrix
	matrix_params = get_matrix_params(data)

	#generate and return a rad_sim struct
	rad_sim = RadSim(
		[matrix_params["γ_matrix"][:, :, i] for i in 1:size(matrix_params["γ_matrix"], 3)],
		matrix_params["Δxy"],
		matrix_params["Δz"],
		matrix_params["Lxy"],
		matrix_params["Lz"],
		x₀
	)
	return rad_sim
end

"""
Helper function used by `import_data()` to convert the dictionary read from the text file into dictionary containing the components necessary to make a RadSim struct.

# arguments
* `data::Dict` - the dictionary made within `import_data()` that contains keys:
`"y_bin_bounds"`, `"Δxy"`, `"z_bin_bounds"`, `"Δz"`, `"Lxy"`, `"Lz"`, `"energy_field_data"`
"""
function get_matrix_params(data::Dict)

	parameters = Dict()

	#Δx,y and L parameters
	Δxy = data["y_bin_bounds"][2] - data["y_bin_bounds"][1]
	parameters["Δxy"] = Δxy
	Δz = data["z_bin_bounds"][2] - data["z_bin_bounds"][1]
	parameters["Δz"] = Δz 
	parameters["Lxy"] = (length(data["x_bin_bounds"])-1) * Δxy
	parameters["Lz"] = (length(data["z_bin_bounds"])-1) * Δz

	#assert square grid
	@assert Δxy == data["x_bin_bounds"][2] - data["x_bin_bounds"][1] "x and y should have the same grid spacing!"
	

	norm_gamma_matrix = zeros(length(data["x_bin_bounds"])-1,
							 length(data["y_bin_bounds"])-1,
							 length(data["z_bin_bounds"])-1
							 )


	for row in eachrow(data["energy_field_data"])
		x_start = data["x_bin_bounds"][1]
		y_start = data["y_bin_bounds"][1]
		z_start = data["z_bin_bounds"][1]
	    # Compute indices from coordinates
	    i = Int(round((row["X"] - x_start) / Δxy + 0.5))
	    j = Int(round((row["Y"] - y_start)  / Δxy + 0.5))
	    k = Int(round((row["Z"] - z_start)  / Δz + 0.5))
	
		norm_gamma_matrix[i, j, k] = row["Result"]
	end

	parameters["γ_matrix"] = norm_gamma_matrix

	return parameters
end

end